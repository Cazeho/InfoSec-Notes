# Java Remote Method Invocation - Methodology

### Overview

`Java Remote Method Invocation (Java RMI)` is a set of Java APIs that allows
Java objects running on separate `Java Virtual Machines (JVM)` to communicate.
In some regards, it can be considered the Java object-oriented equivalent of
`Remote Procedure Calls (RPC)`, with the support of transfer of serialized
Java classes and a distributed garbage collector.

As stated in the official Java documentation regarding `Java RMI` applications:
"A typical server program creates some remote objects, makes references to
these objects accessible, and waits for clients to invoke methods on these
objects. A typical client program obtains a remote reference to one or more
remote objects on a server and then invokes methods on them".

The original implementation of `Java RMI` relied on the `Java Remote Method
Protocol (JRMP)` protocol (over `TCP` / `IP`). The `JRMP` protocol is specific
to Java and can only be used to make calls from a `JVM` to another. An
implementation based on the `Common Object Request Broker Architecture (CORBA)`
standard was later implemented to support communications between non-`JVM`
components. This implementation rely on the `RMI over Internet Inter-Orb
Protocol (RMI-IIOP)` protocol. While older, the `RMI-JRMP` implementation is
still actively maintained, more integrated into Java and easier to use than
the more complicated `RMI-IIOP` implementation.

The official `TCP` port linked to the `JRMP` protocol (more precisely to the
`RMI registry` component used by the protocol) is **1099** while the TCP port
usually linked to the `RMI-IIOP` protocol is **1050**.

###### Stub and Skeleton classes

In `Java RMI`, the client side object, usually simply referred to as the client,
communicate through `Stub` classes to server side objects on the `Java RMI`
server. The `Stub` classes act as client-side gateway for all requests to
remote objects. The remote object's stub instance is what the client will use
to make remote method calls to the remote object.

Before `Java Standard Edition (Java SE)` 5, stub classes had to be
pre-generated from the compiled code (`.class`) of the server-side class that
would be called. This step is no longer required, as the stub classes can now
be directly retrieved from the `Java RMI` server.

The `Skeleton` class used to be the server-side equivalent of the `Stub`
classes to process all incoming clients requests. Skeletons are deprecated
since `J2SE 1.2` (1998).

###### RMI registry and invocation process

The `RMI registry` is a naming service that hold information about the remote
objects registered by `Java RMI` servers.  

The `Java RMI` servers call the `Java RMI registry` to register (remote)
object(s) and  associate a name with each registered object, an operation known
as `binding`. When `Java RMI` clients request a reference to a named remote
object, a `lookup` to the `RMI registry` is first performed by the clients to
retrieve the remote object associated to the given name. The `Java RMI
registry` returns a reference, which correspond to the remote object's `stub`
instance, to the client. This reference is then used to call the methods of the
remote object.

###### Remote class loading

As stated, `Java RMI` supports the transfer of serialized objects over the
network. In order to deserialize any serialized object received (that is
transform back the serialized objects to object instances), the `JVM` must have access to the bytecode of the class of the object being deserialized.

Under certain circumstances, remote classes can be loaded by the `JVM` upon
reception of a serialized object (as an argument or return value) to a `Java
RMI` call, **thus resulting in code execution from the sending `JVM`**. As some
methods of `Java RMI` servers can be called by default by unauthenticated
users, remote class loading would allow unauthenticated remote code execution
on the server hosting the `Java RMI` service, under the security context and
privileges of the `JVM`.

The following conditions must be met for remote class loading to be enabled:
  - The class to load should not exist locally, that is should not be present
    in the `CLASSPATH` of the local `JVM`.

  - The `SecurityManager` should be enabled on the receiving `JVM`.

  - The receiving `JVM`'s `java.rmi.server.useCodebaseOnly` property should be
    be set to `false`. Since `JDK 7u21` (released in 2013), the
    `java.rmi.server.useCodebaseOnly` property is set to `true` by default
    (and was set to `false` in prior releases).

If the conditions for remote class loading are met, the loader will use, when
marshalling objects, the codebase `URL` specified in the `annotation` of the
object's class to download the definition of the class.

### Network scan

`nmap` can be used to scan the network for `Java RMI` services:

```
nmap -v -p 1050,1098,1099 -sV -sC -oA nmap_javarmi <RANGE | CIDR>
```

### Remote class loading

###### Detection

The `nmap` `NSE` script `rmi-vuln-classloader` and the `Metasploit` module
`auxiliary/scanner/misc/java_rmi_server` can be used to check if `Java RMI`
servers allow remote class loading.

Note however that the aforementioned tooling are, as of March 2021, [prone to
false-positives](https://github.com/rapid7/metasploit-framework/issues/10090)
likely due to the original exploit code dating back to before the `JDK 7u21`
default configuration hardening.  

```
nmap -v -p <PORT> -sV --script rmi-vuln-classloader <IP | RANGE | CIDR>

msf > use auxiliary/scanner/misc/java_rmi_server
```

###### Exploitation

The `Metasploit` module `exploit/multi/misc/java_rmi_server` can be used to
exploit `Java RMI` server allowing remote class loading to execute system
commands.

In order to be successful, the exploitation requires:
  - that the attacking machine can be reached by the `Java RMI` server (to
    retrieve the class on a webserver hosted by `Metasploit`)
  - the `Runtime.getRuntime().exec()` method can be called

Note that `Runtime.getRuntime().exec()` does make use of a shell (such as
`/bin/sh`) to deport arguments parsing. Instead it splits the command line in
an array of words, with the first word being executed and the others words used
as arguments. **In result, shell metacharacters** (`|`, `;`, `&`, `>`, `<`,
etc.) **are not supported by `Runtime.getRuntime().exec()`.**

```
msf > use exploit/multi/misc/java_rmi_server
```
