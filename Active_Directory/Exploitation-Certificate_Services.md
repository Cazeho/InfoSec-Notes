# Active Directory - Certificate Services

### Overview

###### Active Directory: Public Key Services containers

A number of Active Directory objects, stored in the `Configuration` naming
context, are related to `Active Directory Certificate Services` (and
potentially third-party `Certification Authority`). As any objects stored in
the `Configuration` naming context, the objects are replicated on all the
Domain Controllers forest-wide.

| Name | Path | Description |
|------|------|-------------|
| `NTAuthCertificates` | `CN=NTAuthCertificates,CN=Public Key Services,CN=Services,CN=Configuration,<DOMAIN>` | The `NTAuthCertificates` store, also known as the `Enterprise NTAuth store` store, hold the certificate of the trusted `Certificate Authorities` (in the `cACertificate` attribute). |
| `Enrollment Services` | `CN=Enrollment Services,CN=Public Key Services,CN=Services,CN=Configuration,<DOMAIN>` |  |
| `Certificate Authority` | `CN=Certification Authorities,CN=Public Key Services,CN=Services,CN=Configuration,<DOMAIN>` | |
| `Certificate Templates` | `CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,<DOMAIN>` | Container holding the `certificate templates` defined in the domain, whether they are enabled in a `Certificate Authority` or not. |
| `CDP` | `CN=<CA_NAME>,CN=<ADCS_SERVER>,CN=CDP,CN=Public Key Services,CN=Services,CN=Configuration,<DOMAIN>` | Container storing the `Certificate Revocation Lists (CRL)`, with one separate container per `CA` and each `CA` thus having its own `CRL`. |

###### Certificate template

`Certificate templates` are domain objects of type `pKICertificateTemplate`,
stored under the `CN=Certificate Templates,CN=Public Key
Services,CN=Services,CN=Configuration,DC=<DOMAIN>,DC=<TLD>` container, that
govern the certificates that can be requested to and delivered by the
`Active Directory Certificate Services (AD CS)`.

A `certificate template` notably defines a number of parameters for the
certificates issued through the template:

  - The way the `Subject Name` of the certificates will be constructed. The
    `Subject Name` can be either build:
      - automatically based on `Active Directory` information of the principal
       making the request (`User Principal Name (UPN)`,
       `Service Principal Name (SPN)`, `DNS` name, etc.).

      - using user-supplied data provided in the certificate request. In such
        case, the `CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT` (`0x1`) in the
        `msPKI-Certificate-Name-Flag` attribute is set (and the attribute thus
        has an odd value).

  - The issued certificates validity period.

  - The cryptographic parameters of the certificates (the
    `Cryptographic Services Provider (CSP)` and the minimum key size used for
    instance).

  - The `X509v3` extensions added to the certificates, including the
    `Extended / Enhanced Key Usage (EKU)` extension (introduced in more details
    below). The extensions define the purpose of the certificates.

  - Eventual issuance requirements:
      - Approval of a certificate manager to validate (or deny) the
        certificate request. This setting will set the
        `CT_FLAG_PEND_ALL_REQUESTS` (`0x02)` flag in the certificate template
        `msPKI-Enrollment-Flag` attribute.  Certificate requests will be keep
        in a pending state, awaiting for action of the certificate manager.

Additionally, `certificate templates` are `securable objects`, and the access
control rights defined in a `certificate template`'s
`Access Control List (ACL)` govern the operations that can be conducted on the
template itself and the principals that can enroll to the template. Refer to
the `[Active Directory] ACL exploiting - Active Directory Certificate Services`
note for more information on the `certificate templates` `ACL`.

###### Extended / Enhanced Key Usage extension

The `Extended / Enhanced Key Usage (EKU)` extension is a certificate extension
(i.e an additional attribute) that defines the purposes of the certificate,
effectively restricting what the certificate can be used for in an Active
Directory environment. This extension is implemented by the
`pKIExtendedKeyUsage` attribute on Active Directory certificate template
object.

The `EKU` extension is composed of 0 or more `Object Identifier (OID)`, each
`OID` corresponding to a specific purpose. The following notable `OIDs` are
supported in Active Directory:

| OID | Name / Description | Usage | Allow AD authentication |
|-----|--------------------|-------|-------------------------|
| `2.5.29.37.0` | `anyExtendedKeyUsage` | Certificate that can be used for any usage. | Yes. |
| `1.3.6.1.5.5.7.3.2` | `clientAuth` | Certificate used for client authentication (be it  `SSL` / `TLS` authentication for web client or to remote servers in Active Directory). | Yes. |
| `1.3.6.1.5.5.7.3.3` | `codeSigning` | Code signing certificate used to digitally sign executables (such as `PE` binaries or PowerShell scripts). | No. |
| `1.3.6.1.5.5.7.3.4` | `emailProtection` | Certificate used to encrypt or digitally sign emails through the `S/MIME` standard. | No. |
| `1.3.6.1.5.5.7.3.5` <br> `1.3.6.1.5.5.7.3.6` <br> `1.3.6.1.5.5.7.3.7` | `ipsecEndSystem` <br> `ipsecTunnel` <br> `ipsecUser` | Certificates used in an Internet Protocol SECurity (IPSEC) infrastructure. | No. |
| `1.3.6.1.5.2.3.4` | `keyPurposeClientAuth` | Certificate used in Active Directory for PKINIT client authentication (not present by default and requires to be manually added in the certificate template). | Yes. |
| `1.3.6.1.4.1.311.10.3.4` | `msEFS` | Certificate used to encrypt / decrypt `Encrypting File System (EFS)` `NTFS` filesystems on Windows. | No. |
| `1.3.6.1.5.5.7.3.1` | `serverAuth` | Certificate used for server authentication (for instance using the `SSL` / `TLS` protocol). | No. |
| `1.3.6.1.4.1.311.20.2.2` | `Smartcard logon` | Certificate used for smart card logon. | Yes. |

If no `OID` is specified in the `EKU` extension, the certificate will by
default be valid for all usages in Windows, including client authentication.
Applications may however rely on the `Constrained` `EKU` validation mode,
as implemented by Microsoft, which determine the valid usage of the certificate
using only the explicitly specified purposes (in all the certificate of the
chain).

###### Enrollment rights

To enroll for a `certificate template`, the following conditions must be meet:

  - The `certificate template` must be published by at least one `Certificate
    Authority`. The `certificate templates` published by a given `CA` are
    defined in the `certificateTemplates` attribute of the `CA`'s `Enrollment
    Service` (`pKIEnrollmentService`) object.

  - The given principal must be able to enroll to a `CA` publishing the
    `certificate template` (`Certificate-Enrollment` or
    `Certificate-AutoEnrollment` extended rights).

  - The given principal must have enrollment rights for the `certificate
    template`. The enrollment rights are defined on the `certificate
    template` object's `ACL` (notably the `Certificate-Enrollment` or
    `Certificate-AutoEnrollment` rights).

### Certificate Authorities enumeration

The following PowerShell script uses the `ActiveDirectory` module to
enumerate each `CA`'s published `certificate templates` and, direct or indirect
enrollment rights:

```bash
# Enumerates the CA and the principals having, directly or indirectly, enroll rights over each CA.
# Requires the ActiveDirectory PowerShell module: Import-Module ActiveDirectory.
$DomainRoot = "<DOMAIN_ROOT_OBJECT>"
Get-ChildItem "AD:\CN=Enrollment Services,CN=Public Key Services,CN=Services,CN=Configuration,$DomainRoot" | ForEach-Object {
  Write-Host "CA: $_ `n"
  Write-Host "Published certificate templates:"
  Get-ADObject "$_" -Properties certificateTemplates | Select-Object -ExpandProperty certificateTemplates
  Write-Host "`n";
  Write-Host "Enrollment rights:"
  Get-Acl "AD:\$_" | Select-Object -ExpandProperty Access |
  Where-Object {(
  $_.ActiveDirectoryRights -match 'WriteProperty|GenericAll|GenericWrite|WriteDacl|WriteOwner'`
  -or ($_.ActiveDirectoryRights -match 'ExtendedRight' -and $_.ObjectType -match '00000000-0000-0000-0000-000000000000|0e10c968-78fb-11d2-90d4-00c04f79dc55|0e10c968-78fb-11d2-90d4-00c04f79dc55')`
  -and $_.AccessControlType -eq "Allow" -and $_.PropagationFlags -ne "InheritOnly")}
}
```

### Certificate templates enumeration

Multiple tools and utilities, including
`certutil`, [`Certify`](https://github.com/GhostPack/Certify) and
[`Invoke-Leghorn`](https://github.com/RemiEscourrou/Invoke-Leghorn/), can be
used to enumerate the `certificate templates`. `PingCastle`'s `healthcheck`
module includes a review of the `certificate templates`.

For the enumeration and exploitation of the access rights defined on
`certificate templates`, refer to the
`[ActiveDirectory] ACL exploiting - Active Directory Certificate Services`
note.

```bash
# Enumerates the enabled certificate templates and returns whether enrollment is possible under the current security context.
certutil -CATemplates

# Enumerates all enabled (i.e template supported by a CA) certificate templates.
# /clientauth: limit the enumeration to certificate templates that can be used for client authentication.
# /enrolleeSuppliesSubject: limit the enumeration to certificate templates where the Subject Name is user-supplied (ENROLLEE_SUPPLIES_SUBJECT set).
Certify.exe find [/clientauth] [/enrolleeSuppliesSubject] [/ca:<HOSTNAME>\<CA_NAME> | /domain:<DOMAIN> | /path:CN=Configuration,<DOMAIN_ROOT_OBJECT>]

# Enumerates the certificate templates exploitable under the current user security context.
Certify.exe find [/ca:<HOSTNAME>\<CA_NAME> | /domain:<DOMAIN> | /path:CN=Configuration,<DOMAIN_ROOT_OBJECT>] /vulnerable /currentuser

# Enumerates the certificate templates exploitable by default low-privileged groups (Domain Users, Domain Computers, Everyone, etc.).
Certify.exe find [/ca:<HOSTNAME>\<CA_NAME> | /domain:<DOMAIN> | /path:CN=Configuration,<DOMAIN_ROOT_OBJECT>] /vulnerable

# The Get-CATemplate cmdlet is part of the ADCSAdministration module.
Get-CATemplate

# PowerShell script with no external dependencies that enumerate vulnerable certificate template.
Invoke-Leghorn -Domain <DOMAIN>
```

The following PowerShell code enumerates all the `certificate templates` and
returns a number of information for each template:
  - `Certificate Authorities` publishing the `certificate template`, if any.
  - Purposes, highlighting client authentication.
  - Principals having direct enrollment rights (`GenericAll`,
    `Certificate-Enrollment`, or `Certificate-AutoEnrollment`).
  - Whether the `Subject Name` is user-supplied and the certificate request
    requires an approval.

The published `certificate templates` supporting client authentication,
allowing anyone to enroll without approval, and construct the `Subject Name`
from user-supplied data are highlighted as vulnerable.

```bash
Import-Module ActiveDirectory

$DomainRoot = "<DOMAIN_ROOT_OBJECT>"

# For execution on non domain-joined machine, sets default parameters for all ActiveDirectory cmdlets.
<#
$DC = '<DC_IP>'
$PSCredential = Get-Credential
$ADDrive = "ADX"
$PSDefaultParameterValues = @{"*-AD*:Server"=$DC}
$PSDefaultParameterValues = @{"*-AD*:Credential"=$PSCredential}
New-PSDrive -Name $ADDrive -PSProvider ActiveDirectory -Root "//RootDSE/" -Server $DC -Credential $PSCredential
#>

# To comment out for execution on non domain-joined machine.
$ADDrive = "AD"

$ClientAuthOIDRegex = [string]::Join('|', @('2.5.29.37.0', '1.3.6.1.5.5.7.3.2', '1.3.6.1.5.2.3.4', '1.3.6.1.4.1.311.20.2.2'))
$PrivilegedPrincipalsRegex = [string]::Join('|', @('Domain Admins', 'Enterprise Admins', 'Domain Controllers'))
$UnprivilegedPrincipalsRegex = [string]::Join('|', @('Domain Users', 'Everyone', 'Domain Computers', 'Authenticated Users', 'Anonymous', 'Users'))

# Retrieves the Certificate Templates published by Certificate Auhtorities.

$CACertificateTemplatesTable = @{}
Get-ChildItem "${ADDrive}:\CN=Enrollment Services,CN=Public Key Services,CN=Services,CN=Configuration,$DomainRoot" | ForEach-Object {
  $CA = Get-ADObject "$_" -Properties name | Select-Object -ExpandProperty name
  $CACertificateTemplates = Get-ADObject "$_" -Properties certificateTemplates | Select-Object -ExpandProperty certificateTemplates
  $CACertificateTemplates | ForEach-Object {
    If ($CACertificateTemplatesTable.ContainsKey($_)) { $CACertificateTemplatesTable[$_] += $CA }
    Else {
      $CACertificateTemplatesTable[$_] = @()
      $CACertificateTemplatesTable[$_] += $CA
    }
  }
}

# Enumerates the Certificate Templates.
Get-ChildItem "${ADDrive}:\CN=Certificate Templates,CN=Public Key Services,CN=Services,CN=Configuration,$DomainRoot" | ForEach-Object {
  $CT = Get-ADObject "$_" -Properties *
  $vulnerableCT = $True
  Write-Host -ForegroundColor DarkGreen -BackgroundColor White "Certificate template: $CT.name `n";

  Write-Host -ForegroundColor Cyan "Purpose(s):`n"
  $CT."pKIExtendedKeyUsage" | ForEach-Object {
    If ($_ -match $ClientAuthOIDRegex) { Write-Host -ForegroundColor Green $_ }
    Else { Write-Host $_ }
  }
  Write-Host "`n"
  If ($CT."pKIExtendedKeyUsage" -match $ClientAuthOIDRegex) {
    Write-Host -ForegroundColor Green "Certificate template supports client authentication!"
  }
  Else {
    Write-Host -ForegroundColor Red "Certificate template does not support client authentication."
    $vulnerableCT = $False
  }
  Write-Host "`n"

  Write-Host -ForegroundColor Cyan "Published in Certificate Authorities:`n"
  If ($CACertificateTemplatesTable.ContainsKey($CT.name)) {
    $CACertificateTemplatesTable[$CT.name]
    Write-Host "`n"
    Write-Host -ForegroundColor Green "Certificate template is published."
  }
  Else {
    Write-Host -ForegroundColor Red "Certificate template is not published."
    $vulnerableCT = $False
  }
  Write-Host "`n"


  Write-Host -NoNewline -ForegroundColor Cyan "User-supplied Subject Name: "
  If (($CT."msPKI-Certificate-Name-Flag" -band 0x1) -ne '0') {
    Write-Host -ForegroundColor Green "YES"
  }
  Else {
    Write-Host -ForegroundColor Red "NO"
    $vulnerableCT = $False
  }
  Write-Host "`n"

  Write-Host -NoNewline -ForegroundColor Cyan "Requires certificate manager approval: "
  If (($CT."msPKI-Certificate-Name-Flag" -band 0x2) -ne '0') {
    Write-Host -ForegroundColor Red "YES"
    $vulnerableCT = $False
  }
  Else {
    Write-Host -ForegroundColor Green "NO"
  }
  Write-Host "`n"

  $anyoneCanEnroll = $False
  Write-Host -ForegroundColor Cyan "Enrollment rights:`n"
  Get-Acl "${ADDrive}:\$_" | Select-Object -ExpandProperty Access |
  Where-Object {(
  $_.ActiveDirectoryRights -match 'GenericAll'`
  -or ($_.ActiveDirectoryRights -match 'ExtendedRight' -and $_.ObjectType -match '00000000-0000-0000-0000-000000000000|0e10c968-78fb-11d2-90d4-00c04f79dc55|0e10c968-78fb-11d2-90d4-00c04f79dc55')`
  -and $_.AccessControlType -eq "Allow" -and $_.PropagationFlags -ne "InheritOnly")} | ForEach-Object {
    If ($_.IdentityReference -match $UnprivilegedPrincipalsRegex) {
      Write-Host -ForegroundColor Green $_.IdentityReference
      $anyoneCanEnroll = $True
    }
    ElseIf ($_.IdentityReference -match $PrivilegedPrincipalsRegex) {
      Write-Host -ForegroundColor Red $_.IdentityReference
    }
    Else { Write-Host -ForegroundColor Yellow $_.IdentityReference }
    $_
    Write-Host "`n"
  }

  $vulnerableCT = $vulnerableCT -and $anyoneCanEnroll
  If ($vulnerableCT) {
    Write-Host -ForegroundColor White -BackgroundColor Black "Found vulnerable certificate template: " $CT.name "`n`n";
  }
}
```

### Certificate request and usage

```bash
Certify.exe request /ca:<DOMAIN_FQDN>\<CA> /template:<CERTIFICATE_TEMPLATE>

Rubeus.exe asktgt /user:<USERNAME> /certificate:<PFX_FILE_PATH> /password:<CERTIFICATE_PASSWORD>
```

### Certificates exploitation for privilege escalation

###### Dangerous rights on certificate template or on the Certificate Authority itself

Refer to the
`[ActiveDirectory] ACL exploiting - Active Directory Certificate Services` note
for more information, techniques, and tools to enumerate and exploit dangerous
rights on `CA` objects or `certificate templates`.

###### Certificate template with arbitrary subjectAltName (CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT flag)

###### Certificate template with arbitrary subjectAltName (EDITF_ATTRIBUTESUBJECTALTNAME2 flag)

###### Certificate template with Certificate Request Agent EKU but not Enrollment agent restrictions CA-side

###### Client authentication certificate request through NTLM relaying

###### Code signing certificate

`Code Signing` certificates (`OID 1.3.6.1.5.5.7.3.3`) can be used to sign `PE`
binaries or PowerShell scripts.

Digitally signed executables can be exempted from `User Account Control (UAC)`
or `Windows SmartScreen` prompt. Additionally, on systems with `AppLocker`
enabled, `Windows Installer` files digitally signed by a trusted publisher can
be installed by non-privileged users, resulting in a potential local privilege
escalation.

```bash
# Lists the certificates with code-signing authority stored in the specified certificate store.
Get-ChildItem -Path Cert:<\CurrentUser\My | CERTIFICATE_STORE> -CodeSigningCert

# Uses a code-signing certificate in the specified store.
$cert = Get-ChildItem -Path Cert:<\CurrentUser\My | CERTIFICATE_STORE> -CodeSigningCert

# Uses the specified PFX certificate file.
$cert = Get-PfxCertificate -FilePath <CERTIFICATE_PFX>

# Signs the given file using the code-signing certificate specified.
Set-AuthenticodeSignature -Certificate $cert [-HashAlgorithm <sha1 | sha256>] [-TimestampServer "<http://timestamp.digicert.com | TIMESTAMP_SERVER_URL>"] -FilePath <FILE_TO_SIGN>
```

--------------------------------------------------------------------------------

### References

https://www.riskinsight-wavestone.com/en/2021/06/microsoft-adcs-abusing-pki-in-active-directory-environment/
https://posts.specterops.io/certified-pre-owned-d95910965cd2
https://www.specterops.io/assets/resources/Certified_Pre-Owned.pdf
https://www.sysadmins.lv/blog-en/understanding-active-directory-certificate-services-containers-in-active-directory.aspx
https://ldapwiki.com/wiki/ExtendedKeyUsage
https://www.sysadmins.lv/blog-en/constraining-extended-key-usages-in-microsoft-windows.aspx
